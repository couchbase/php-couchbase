// File autogenerated, do not modify directly!
typedef struct { const char * filename; const char * data; } pcbc_stub_data;
pcbc_stub_data PCBC_PHP_CODESTR[] = {
{"[CouchbaseNative]/constants.php","\n" \
"/**\n" \
" * Various constants used for flags, data-type encoding and decoding, etc...\n" \
" * throughout this SDK.\n" \
" *\n" \
" * @author Brett Lawson <brett19@gmail.com>\n" \
" */\n" \
"\n" \
"/** @internal */ define('COUCHBASE_VAL_MASK', 0x1F);\n" \
"/** @internal */ define('COUCHBASE_VAL_IS_STRING', 0);\n" \
"/** @internal */ define('COUCHBASE_VAL_IS_LONG', 1);\n" \
"/** @internal */ define('COUCHBASE_VAL_IS_DOUBLE', 2);\n" \
"/** @internal */ define('COUCHBASE_VAL_IS_BOOL', 3);\n" \
"/** @internal */ define('COUCHBASE_VAL_IS_SERIALIZED', 4);\n" \
"/** @internal */ define('COUCHBASE_VAL_IS_IGBINARY', 5);\n" \
"/** @internal */ define('COUCHBASE_VAL_IS_JSON', 6);\n" \
"/** @internal */ define('COUCHBASE_COMPRESSION_MASK', 0x7 << 5);\n" \
"/** @internal */ define('COUCHBASE_COMPRESSION_NONE', 0 << 5);\n" \
"/** @internal */ define('COUCHBASE_COMPRESSION_ZLIB', 1 << 5);\n" \
"/** @internal */ define('COUCHBASE_COMPRESSION_FASTLZ', 2 << 5);\n" \
"/** @internal */ define('COUCHBASE_COMPRESSION_MCISCOMPRESSED', 1 << 4);\n" \
"\n" \
"/** @internal */ define('COUCHBASE_SERTYPE_JSON', 0);\n" \
"/** @internal */ define('COUCHBASE_SERTYPE_IGBINARY', 1);\n" \
"/** @internal */ define('COUCHBASE_SERTYPE_PHP', 2);\n" \
"/** @internal */ define('COUCHBASE_CMPRTYPE_NONE', 0);\n" \
"/** @internal */ define('COUCHBASE_CMPRTYPE_ZLIB', 1);\n" \
"/** @internal */ define('COUCHBASE_CMPRTYPE_FASTLZ', 2);\n" \
"\n" \
"/** @internal */ define('COUCHBASE_CFFMT_MASK', 0xFF << 24);\n" \
"/** @internal */ define('COUCHBASE_CFFMT_PRIVATE', 1 << 24);\n" \
"/** @internal */ define('COUCHBASE_CFFMT_JSON', 2 << 24);\n" \
"/** @internal */ define('COUCHBASE_CFFMT_RAW', 3 << 24);\n" \
"/** @internal */ define('COUCHBASE_CFFMT_STRING', 4 << 24);\n" \
""},
{"[CouchbaseNative]/connstr.php","\n" \
"/**\n" \
" * Various helpers for dealing with connection strings.\n" \
" *\n" \
" * @author Brett Lawson <brett19@gmail.com>\n" \
" */\n" \
"\n" \
"/**\n" \
" * Normalizes a connection string object.\n" \
" *\n" \
" * @param $dsnObj A connstr object.\n" \
" * @return array\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function _cbdsn_normalize($dsnObj) {\n" \
"    $out = array();\n" \
"\n" \
"    if (isset($dsnObj['scheme'])) {\n" \
"        $out['scheme'] = $dsnObj['scheme'];\n" \
"    } else {\n" \
"        $out['scheme'] = '';\n" \
"    }\n" \
"\n" \
"    $out['hosts'] = array();\n" \
"    if (isset($dsnObj['hosts'])) {\n" \
"        if (is_string($dsnObj['hosts'])) {\n" \
"            $dsnObj['hosts'] = array($dsnObj['hosts']);\n" \
"        }\n" \
"\n" \
"        foreach($dsnObj['hosts'] as $host) {\n" \
"            if (is_string($host)) {\n" \
"                $portPos = strstr($host, ':');\n" \
"                if ($portPos) {\n" \
"                    $hostName = substr($host, 0, $portPos);\n" \
"                    $portNum = intval(substr($host, $portPos+1));\n" \
"                    array_push($out['hosts'], array(\n" \
"                        $hostName, $portNum\n" \
"                    ));\n" \
"                } else {\n" \
"                    array_push($out['hosts'], $host);\n" \
"                }\n" \
"            } else {\n" \
"                array_push($out['hosts'], $host);\n" \
"            }\n" \
"        }\n" \
"    }\n" \
"\n" \
"    if (isset($dsnObj['bucket'])) {\n" \
"        $out['bucket'] = $dsnObj['bucket'];\n" \
"    } else {\n" \
"        $out['bucket'] = 'default';\n" \
"    }\n" \
"\n" \
"    if (isset($dsnObj['options'])) {\n" \
"        $out['options'] = $dsnObj['options'];\n" \
"    } else {\n" \
"        $out['options'] = array();\n" \
"    }\n" \
"\n" \
"    return $out;\n" \
"}\n" \
"\n" \
"/**\n" \
" * Normalizes a connection string object or string.\n" \
" *\n" \
" * @param $dsn A connection string or connstr object.\n" \
" * @return array|string\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function cbdsn_normalize($dsn) {\n" \
"    if (is_string($dsn)) {\n" \
"        return _cbdsn_stringify(\n" \
"            _cbdsn_normalize(\n" \
"                _cbdsn_parse($dsn)\n" \
"            )\n" \
"        );\n" \
"    }\n" \
"    return _cbdsn_normalize($dsn);\n" \
"}\n" \
"\n" \
"/**\n" \
" * Parses a connection string into a object.\n" \
" *\n" \
" * @param $dsn A connection string.\n" \
" * @return array\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function _cbdsn_parse($dsn) {\n" \
"    $out = array();\n" \
"\n" \
"    if (!$dsn) {\n" \
"        return $out;\n" \
"    }\n" \
"\n" \
"    preg_match(\"/((.*):\\\\/\\\\/)?([^\\\\/?]*)(\\\\/([^\\\\?]*))?(\\\\?(.*))?/\", $dsn, $parts);\n" \
"    if (isset($parts[2])) {\n" \
"        $out['scheme'] = $parts[2];\n" \
"    }\n" \
"    if (isset($parts[3])) {\n" \
"        $out['hosts'] = array();\n" \
"\n" \
"        preg_match_all(\"/([^;\\\\,\\\\:]+)(:([0-9]*))?(;\\\\,)?/\", $parts[3], $hosts, PREG_SET_ORDER);\n" \
"        foreach($hosts as $host) {\n" \
"            array_push($out['hosts'], array(\n" \
"                $host[1],\n" \
"                isset($host[3]) ? intval($host[3]) : 0\n" \
"            ));\n" \
"        }\n" \
"    }\n" \
"    if (isset($parts[5])) {\n" \
"        $out['bucket'] = $parts[5];\n" \
"    }\n" \
"    if (isset($parts[7])) {\n" \
"        $out['options'] = array();\n" \
"\n" \
"        preg_match_all(\"/([^=]*)=([^&?]*)[&?]?/\", $parts[7], $kvs, PREG_SET_ORDER);\n" \
"        foreach($kvs as $kv) {\n" \
"            array_push($out['options'], array(urldecode($kv[1]), urldecode($kv[2])));\n" \
"        }\n" \
"    }\n" \
"\n" \
"    return $out;\n" \
"}\n" \
"\n" \
"/**\n" \
" * Parses a connection string and ensures its normalized.\n" \
" *\n" \
" * @param $dsn A connection string.\n" \
" * @return array\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function cbdsn_parse($dsn) {\n" \
"    return _cbdsn_normalize(_cbdsn_parse($dsn));\n" \
"}\n" \
"\n" \
"/**\n" \
" * Converts a connstr object to a connection string.\n" \
" *\n" \
" * @param $dsnObj\n" \
" * @return string\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function _cbdsn_stringify($dsnObj) {\n" \
"    $dsn = '';\n" \
"\n" \
"    if ($dsnObj['scheme']) {\n" \
"        $dsn .= $dsnObj['scheme'] . '://';\n" \
"    }\n" \
"\n" \
"    foreach($dsnObj['hosts'] as $i => $host) {\n" \
"        if ($i !== 0) {\n" \
"            $dsn .= ',';\n" \
"        }\n" \
"        $dsn .= $host[0];\n" \
"        if ($host[1]) {\n" \
"            $dsn .= ':' . $host[1];\n" \
"        }\n" \
"    }\n" \
"\n" \
"    if ($dsnObj['bucket']) {\n" \
"        $dsn .= '/' . $dsnObj['bucket'];\n" \
"    }\n" \
"\n" \
"    if ($dsnObj['options']) {\n" \
"        $isFirstOption = true;\n" \
"        foreach($dsnObj['options'] as $kvpair) {\n" \
"            if ($isFirstOption) {\n" \
"                $dsn .= '?';\n" \
"                $isFirstOption = false;\n" \
"            } else {\n" \
"                $dsn .= '&';\n" \
"            }\n" \
"            $dsn .= urlencode($kvpair[0]) . '=' . urlencode($kvpair[1]);\n" \
"        }\n" \
"    }\n" \
"\n" \
"    return $dsn;\n" \
"}\n" \
"\n" \
"/**\n" \
" * Ensures a connstr object is normalized then generates a connection string.\n" \
" *\n" \
" * @param $dsnObj\n" \
" * @return string\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function cbdsn_stringify($dsnObj) {\n" \
"    return _cbdsn_stringify(_cbdsn_normalize($dsnObj));\n" \
"}\n" \
""},
{"[CouchbaseNative]/default_transcoder.php","\n" \
"/**\n" \
" * Various transcoder functions that are packaged by default with the\n" \
" * PHP SDK.\n" \
" *\n" \
" * @author Brett Lawson <brett19@gmail.com>\n" \
" */\n" \
"\n" \
"/**\n" \
" * The default options for V1 encoding when using the default\n" \
" * transcoding functionality.\n" \
" * @internal\n" \
" */\n" \
"$COUCHBASE_DEFAULT_ENCOPTS = array(\n" \
"    'sertype' => COUCHBASE_SERTYPE_JSON,\n" \
"    'cmprtype' => COUCHBASE_CMPRTYPE_NONE,\n" \
"    'cmprthresh' => 0,\n" \
"    'cmprfactor' => 0\n" \
");\n" \
"\n" \
"/**\n" \
" * The default options from past versions of the PHP SDK.\n" \
" * @internal\n" \
" */\n" \
"$COUCHBASE_OLD_ENCOPTS = array(\n" \
"    'sertype' => COUCHBASE_SERTYPE_PHP,\n" \
"    'cmprtype' => COUCHBASE_CMPRTYPE_NONE,\n" \
"    'cmprthresh' => 2000,\n" \
"    'cmprfactor' => 1.3\n" \
");\n" \
"\n" \
"/**\n" \
" * The default options for V1 decoding when using the default\n" \
" * transcoding functionality.\n" \
" * @internal\n" \
" */\n" \
"$COUCHBASE_DEFAULT_DECOPTS = array(\n" \
"    'jsonassoc' => false\n" \
");\n" \
"\n" \
"/**\n" \
" * Performs encoding of user provided types into binary form for\n" \
" * on the server according to the original PHP SDK specification.\n" \
" *\n" \
" * @internal\n" \
" *\n" \
" * @param $value The value passed by the user\n" \
" * @param $options Various encoding options\n" \
" * @return array An array specifying the bytes, flags and datatype to store\n" \
" */\n" \
"function couchbase_basic_encoder_v1($value, $options) {\n" \
"    $data = NULL;\n" \
"    $flags = 0;\n" \
"    $datatype = 0;\n" \
"\n" \
"    $sertype = $options['sertype'];\n" \
"    $cmprtype = $options['cmprtype'];\n" \
"    $cmprthresh = $options['cmprthresh'];\n" \
"    $cmprfactor = $options['cmprfactor'];\n" \
"\n" \
"    $vtype = gettype($value);\n" \
"    if ($vtype == 'string') {\n" \
"        $flags = COUCHBASE_VAL_IS_STRING | COUCHBASE_CFFMT_STRING;\n" \
"        $data = $value;\n" \
"    } else if ($vtype == 'integer') {\n" \
"        $flags = COUCHBASE_VAL_IS_LONG | COUCHBASE_CFFMT_JSON;\n" \
"        $data = (string)$value;\n" \
"        $cmprtype = COUCHBASE_CMPRTYPE_NONE;\n" \
"    } else if ($vtype == 'double') {\n" \
"        $flags = COUCHBASE_VAL_IS_DOUBLE | COUCHBASE_CFFMT_JSON;\n" \
"        $data = (string)$value;\n" \
"        $cmprtype = COUCHBASE_CMPRTYPE_NONE;\n" \
"    } else if ($vtype == 'boolean') {\n" \
"        $flags = COUCHBASE_VAL_IS_BOOL | COUCHBASE_CFFMT_JSON;\n" \
"        $data = $value ? 'true' : 'false';\n" \
"        $cmprtype = COUCHBASE_CMPRTYPE_NONE;\n" \
"    } else {\n" \
"        if ($sertype == COUCHBASE_SERTYPE_JSON) {\n" \
"            $flags = COUCHBASE_VAL_IS_JSON | COUCHBASE_CFFMT_JSON;\n" \
"            $data = json_encode($value);\n" \
"        } else if ($sertype == COUCHBASE_SERTYPE_IGBINARY) {\n" \
"            $flags = COUCHBASE_VAL_IS_IGBINARY | COUCHBASE_CFFMT_PRIVATE;\n" \
"            $data = igbinary_serialize($value);\n" \
"        } else if ($sertype == COUCHBASE_SERTYPE_PHP) {\n" \
"            $flags = COUCHBASE_VAL_IS_SERIALIZED | COUCHBASE_CFFMT_PRIVATE;\n" \
"            $data = serialize($value);\n" \
"        }\n" \
"    }\n" \
"\n" \
"    if (strlen($data) < $cmprthresh) {\n" \
"        $cmprtype = COUCHBASE_CMPRTYPE_NONE;\n" \
"    }\n" \
"\n" \
"    if ($cmprtype != COUCHBASE_CMPRTYPE_NONE) {\n" \
"        $cmprdata = NULL;\n" \
"        $cmprflags = COUCHBASE_COMPRESSION_NONE;\n" \
"\n" \
"        if ($cmprtype == COUCHBASE_CMPRTYPE_ZLIB) {\n" \
"            $cmprdata = couchbase_zlib_compress($data);\n" \
"            $cmprflags = COUCHBASE_COMPRESSION_ZLIB;\n" \
"        } else if ($cmprtype == COUCHBASE_CMPRTYPE_FASTLZ) {\n" \
"            $cmprdata = couchbase_fastlz_compress($data);\n" \
"            $cmprflags = COUCHBASE_COMPRESSION_FASTLZ;\n" \
"        }\n" \
"\n" \
"        if ($cmprdata != NULL) {\n" \
"            if (strlen($data) > strlen($cmprdata) * $cmprfactor) {\n" \
"                $data = $cmprdata;\n" \
"                $flags |= $cmprflags;\n" \
"                $flags |= COUCHBASE_COMPRESSION_MCISCOMPRESSED;\n" \
"\n" \
"                $flags &= ~COUCHBASE_CFFMT_MASK;\n" \
"                $flags |= COUCHBASE_CFFMT_PRIVATE;\n" \
"            }\n" \
"        }\n" \
"    }\n" \
"\n" \
"    return array($data, $flags, $datatype);\n" \
"}\n" \
"\n" \
"/**\n" \
" * Performs decoding of the server provided binary data into\n" \
" * PHP types according to the original PHP SDK specification.\n" \
" *\n" \
" * @internal\n" \
" *\n" \
" * @param $bytes The binary received from the server\n" \
" * @param $flags The flags received from the server\n" \
" * @param $datatype The datatype received from the server\n" \
" * @return mixed The resulting decoded value\n" \
" *\n" \
" * @throws CouchbaseException\n" \
" */\n" \
"function couchbase_basic_decoder_v1($bytes, $flags, $datatype, $options) {\n" \
"    $cffmt = $flags & COUCHBASE_CFFMT_MASK;\n" \
"    $sertype = $flags & COUCHBASE_VAL_MASK;\n" \
"    $cmprtype = $flags & COUCHBASE_COMPRESSION_MASK;\n" \
"\n" \
"    $data = $bytes;\n" \
"    if ($cffmt != 0 && $cffmt != COUCHBASE_CFFMT_PRIVATE) {\n" \
"        if ($cffmt == COUCHBASE_CFFMT_JSON) {\n" \
"            $retval = json_decode($data, $options['jsonassoc']);\n" \
"        } else if ($cffmt == COUCHBASE_CFFMT_RAW) {\n" \
"            $retval = $data;\n" \
"        } else if ($cffmt == COUCHBASE_CFFMT_STRING) {\n" \
"            $retval = (string)$data;\n" \
"        } else {\n" \
"            throw new CouchbaseException(\"Unknown flags value -- cannot decode value\");\n" \
"        }\n" \
"    } else {\n" \
"        if ($cmprtype == COUCHBASE_COMPRESSION_ZLIB) {\n" \
"            $bytes = couchbase_zlib_decompress($bytes);\n" \
"        } else if ($cmprtype == COUCHBASE_COMPRESSION_FASTLZ) {\n" \
"            $data = couchbase_fastlz_decompress($bytes);\n" \
"        }\n" \
"\n" \
"        $sertype &= ~COUCHBASE_COMPRESSION_MCISCOMPRESSED;\n" \
"        $retval = NULL;\n" \
"        if ($sertype == COUCHBASE_VAL_IS_STRING) {\n" \
"            $retval = json_decode($data, $options['jsonassoc']);\n" \
"            if ($retval == NULL) {\n" \
"                $retval = $data;\n" \
"            }\n" \
"        } else if ($sertype == COUCHBASE_VAL_IS_LONG) {\n" \
"            $retval = intval($data);\n" \
"        } else if ($sertype == COUCHBASE_VAL_IS_DOUBLE) {\n" \
"            $retval = floatval($data);\n" \
"        } else if ($sertype == COUCHBASE_VAL_IS_BOOL) {\n" \
"            $retval = $data != \"\";\n" \
"        } else if ($sertype == COUCHBASE_VAL_IS_JSON) {\n" \
"            $retval = json_decode($data, $options['jsonassoc']);\n" \
"        } else if ($sertype == COUCHBASE_VAL_IS_IGBINARY) {\n" \
"            $retval = igbinary_unserialize($data);\n" \
"        } else if ($sertype == COUCHBASE_VAL_IS_SERIALIZED) {\n" \
"            $retval = unserialize($data);\n" \
"        }\n" \
"    }\n" \
"\n" \
"    return $retval;\n" \
"}\n" \
"\n" \
"/**\n" \
" * Default passthru encoder which simply passes data\n" \
" * as-is rather than performing any transcoding.\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function couchbase_passthru_encoder($value) {\n" \
"    return array($value, 0, 0);\n" \
"}\n" \
"\n" \
"/**\n" \
" * Default passthru encoder which simply passes data\n" \
" * as-is rather than performing any transcoding.\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function couchbase_passthru_decoder($bytes, $flags, $datatype) {\n" \
"    return $bytes;\n" \
"}\n" \
"\n" \
"/**\n" \
" * The default encoder for the client.  Currently invokes the\n" \
" * v1 encoder directly with the default set of encoding options.\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function couchbase_default_encoder($value) {\n" \
"    global $COUCHBASE_DEFAULT_ENCOPTS;\n" \
"    return couchbase_basic_encoder_v1($value, $COUCHBASE_DEFAULT_ENCOPTS);\n" \
"}\n" \
"\n" \
"/**\n" \
" * The default decoder for the client.  Currently invokes the\n" \
" * v1 decoder directly.\n" \
" *\n" \
" * @internal\n" \
" */\n" \
"function couchbase_default_decoder($bytes, $flags, $datatype) {\n" \
"    global $COUCHBASE_DEFAULT_DECOPTS;\n" \
"    return couchbase_basic_decoder_v1($bytes, $flags, $datatype, $COUCHBASE_DEFAULT_DECOPTS);\n" \
"}\n" \
""},
{"[CouchbaseNative]/CouchbaseViewQuery.class.php","\n" \
"/**\n" \
" * File for the CouchbaseViewQuery class.\n" \
" */\n" \
"\n" \
"/**\n" \
" * Represents a view query to be executed against a Couchbase bucket.\n" \
" *\n" \
" * @package Couchbase\n" \
" */\n" \
"class CouchbaseViewQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     * @internal\n" \
"     */\n" \
"    public $ddoc = '';\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     * @internal\n" \
"     */\n" \
"    public $name = '';\n" \
"\n" \
"    /**\n" \
"     * @var array\n" \
"     * @internal\n" \
"     */\n" \
"    public $options = array();\n" \
"\n" \
"    const UPDATE_BEFORE = 1;\n" \
"    const UPDATE_NONE = 2;\n" \
"    const UPDATE_AFTER = 3;\n" \
"\n" \
"    const ORDER_ASCENDING = 1;\n" \
"    const ORDER_DESCENDING = 2;\n" \
"\n" \
"    /**\n" \
"     * @internal\n" \
"     */\n" \
"    private function __construct() {\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Creates a new Couchbase ViewQuery instance for performing a view query.\n" \
"     *\n" \
"     * @param $ddoc The name of the design document to query.\n" \
"     * @param $name The name of the view to query.\n" \
"     * @return _CouchbaseDefaultViewQuery\n" \
"     */\n" \
"    static public function from($ddoc, $name) {\n" \
"        $res = new _CouchbaseDefaultViewQuery();\n" \
"        $res->ddoc = $ddoc;\n" \
"        $res->name = $name;\n" \
"        return $res;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Creates a new Couchbase ViewQuery instance for performing a spatial query.\n" \
"     *\n" \
"     * @param $ddoc The name of the design document to query.\n" \
"     * @param $name The name of the view to query.\n" \
"     * @return _CouchbaseSpatialViewQuery\n" \
"     */\n" \
"    static public function fromSpatial($ddoc, $name) {\n" \
"        $res = new _CouchbaseSpatialViewQuery();\n" \
"        $res->ddoc = $ddoc;\n" \
"        $res->name = $name;\n" \
"        return $res;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies the mode of updating to perform before and after executing\n" \
"     * this query.\n" \
"     *\n" \
"     * @param $stale\n" \
"     * @return $this\n" \
"     * @throws CouchbaseException\n" \
"     */\n" \
"    public function stale($stale) {\n" \
"        if ($stale == self::UPDATE_BEFORE) {\n" \
"            $this->options['stale'] = 'false';\n" \
"        } else if ($stale == self::UPDATE_NONE) {\n" \
"            $this->options['stale'] = 'ok';\n" \
"        } else if ($stale == self::UPDATE_AFTER) {\n" \
"            $this->options['stale'] = 'update_after';\n" \
"        } else {\n" \
"            throw new CouchbaseException('invalid option passed.');\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Skips a number of records from the beginning of the result set.\n" \
"     *\n" \
"     * @param $skip\n" \
"     * @return $this\n" \
"     */\n" \
"    public function skip($skip) {\n" \
"        $this->options['skip'] = '' . $skip;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Limits the result set to a restricted number of results.\n" \
"     *\n" \
"     * @param $limit\n" \
"     * @return $this\n" \
"     */\n" \
"    public function limit($limit) {\n" \
"        $this->options['limit'] = '' . $limit;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies custom options to pass to the server.  Note that these\n" \
"     * options are expected to be already encoded.\n" \
"     *\n" \
"     * @param $opts\n" \
"     * @return $this\n" \
"     */\n" \
"    public function custom($opts) {\n" \
"        foreach ($opts as $k => $v) {\n" \
"            $this->options[$k] = $v;\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Generates the view query as it will be passed to the server.\n" \
"     *\n" \
"     * @return string\n" \
"     * @internal\n" \
"     */\n" \
"    public function _toString($type) {\n" \
"        $path = '/_design/' . $this->ddoc . '/' . $type . '/' . $this->name;\n" \
"        $path .= '?' . http_build_query($this->options);\n" \
"        return $path;\n" \
"    }\n" \
"};\n" \
"\n" \
"/**\n" \
" * Represents a regular view query to perform against the server.  Note that\n" \
" * this object should never be instantiated directly, but instead through\n" \
" * the CouchbaseViewQuery::from method.\n" \
" *\n" \
" * @package Couchbase\n" \
" */\n" \
"class _CouchbaseDefaultViewQuery extends CouchbaseViewQuery {\n" \
"\n" \
"    /**\n" \
"     * @internal\n" \
"     */\n" \
"    public function __construct() {\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Orders the results by key as specified.\n" \
"     *\n" \
"     * @param $order\n" \
"     * @return $this\n" \
"     * @throws CouchbaseException\n" \
"     */\n" \
"    public function order($order) {\n" \
"        if ($order == self::ORDER_ASCENDING) {\n" \
"            $this->options['descending'] = 'false';\n" \
"        } else if ($order == self::ORDER_DESCENDING) {\n" \
"            $this->options['descending'] = 'true';\n" \
"        } else {\n" \
"            throw new CouchbaseException('invalid option passed.');\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies a reduction function to apply to the index.\n" \
"     *\n" \
"     * @param $reduce\n" \
"     * @return $this\n" \
"     */\n" \
"    public function reduce($reduce) {\n" \
"        if ($reduce) {\n" \
"            $this->options['reduce'] = 'true';\n" \
"        } else {\n" \
"            $this->options['reduce'] = 'false';\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies the level of grouping to use on the results.\n" \
"     *\n" \
"     * @param $group_level\n" \
"     * @return $this\n" \
"     */\n" \
"    public function group($group) {\n" \
"        if ($group == true) {\n" \
"          $this->options['group'] = 'true';\n" \
"        } else if ($group == false) {\n" \
"          $this->options['group'] = 'false';\n" \
"          \n" \
"        // For backwards compatibility\n" \
"        } else if ($group >= 0) {\n" \
"            $this->options['group'] = 'false';\n" \
"            $this->options['group_level'] = $group;\n" \
"        } else {\n" \
"            $this->options['group'] = 'true';\n" \
"            $this->options['group_level'] = 0;\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"    \n" \
"    /**\n" \
"     * Specifies the level at which to perform view grouping.\n" \
"     * \n" \
"     * @param $group_level\n" \
"     * @returns $this\n" \
"     */\n" \
"    public function group_level($group_level) {\n" \
"        if ($group_level >= 0) {\n" \
"            $this->options['group_level'] = $group_level;\n" \
"        } else {\n" \
"            unset($this->options['group_level']);\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies a specific key to return from the index.\n" \
"     *\n" \
"     * @param $key\n" \
"     * @return $this\n" \
"     */\n" \
"    public function key($key) {\n" \
"        $this->options['key'] = \n" \
"            str_replace('\\\\\\\\', '\\\\', json_encode($key));\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies a list of keys to return from the index.\n" \
"     *\n" \
"     * @param $keys\n" \
"     * @return $this\n" \
"     */\n" \
"    public function keys($keys) {\n" \
"        $this->options['keys'] =\n" \
"            str_replace('\\\\\\\\', '\\\\', json_encode($keys));\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies a range of keys to return from the index.\n" \
"     *\n" \
"     * @param mixed $start\n" \
"     * @param mixed $end\n" \
"     * @param bool $inclusive_end\n" \
"     * @return $this\n" \
"     */\n" \
"    public function range($start = NULL, $end = NULL, $inclusive_end = false) {\n" \
"        if ($start !== NULL) {\n" \
"            $this->options['startkey'] =\n" \
"                str_replace('\\\\\\\\', '\\\\', json_encode($start));\n" \
"        } else {\n" \
"            unset($this->options['startkey']);\n" \
"        }\n" \
"        if ($end !== NULL) {\n" \
"            $this->options['endkey'] =\n" \
"                str_replace('\\\\\\\\', '\\\\', json_encode($end));\n" \
"        } else {\n" \
"            unset($this->options['endkey']);\n" \
"        }\n" \
"        $this->options['inclusive_end'] = $inclusive_end ? 'true' : 'false';\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies a range of document ids to return from the index.\n" \
"     *\n" \
"     * @param null $start\n" \
"     * @param null $end\n" \
"     * @return $this\n" \
"     */\n" \
"    public function id_range($start = NULL, $end = NULL) {\n" \
"        if ($start !== NULL) {\n" \
"            $this->options['startkey_docid'] =\n" \
"                str_replace('\\\\\\\\', '\\\\', json_encode($start));\n" \
"        } else {\n" \
"            $this->options['startkey_docid'] = '';\n" \
"        }\n" \
"        if ($end !== NULL) {\n" \
"            $this->options['endkey_docid'] =\n" \
"                str_replace('\\\\\\\\', '\\\\', json_encode($end));\n" \
"        } else {\n" \
"            $this->options['endkey_docid'] = '';\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Generates the view query as it will be passed to the server.\n" \
"     *\n" \
"     * @return string\n" \
"     */\n" \
"    public function toString() {\n" \
"        return $this->_toString('_view');\n" \
"    }\n" \
"};\n" \
"\n" \
"/**\n" \
" * Represents a spatial view query to perform against the server.  Note that\n" \
" * this object should never be instantiated directly, but instead through\n" \
" * the CouchbaseViewQuery::fromSpatial method.\n" \
" *\n" \
" * @package Couchbase\n" \
" */\n" \
"class _CouchbaseSpatialViewQuery extends CouchbaseViewQuery {\n" \
"\n" \
"    /**\n" \
"     * @internal\n" \
"     */\n" \
"    public function __construct() {\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specifies the bounding box to search within.\n" \
"     *\n" \
"     * @param number[] $bbox\n" \
"     * @return $this\n" \
"     */\n" \
"    public function bbox($bbox) {\n" \
"        $this->options['bbox'] = implode(',', $bbox);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Generates the view query as it will be passed to the server.\n" \
"     *\n" \
"     * @return string\n" \
"     */\n" \
"    public function toString() {\n" \
"        return $this->_toString('_spatial');\n" \
"    }\n" \
"};\n" \
""},
{"[CouchbaseNative]/CouchbaseN1qlQuery.class.php","\n" \
"/**\n" \
" * File for the CouchbaseN1qlQuery class.\n" \
" */\n" \
"\n" \
"/**\n" \
" * Represents a N1QL query to be executed against a Couchbase bucket.\n" \
" *\n" \
" * @package Couchbase\n" \
" */\n" \
"class CouchbaseN1qlQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     * @internal\n" \
"     */\n" \
"    public $options = array();\n" \
"\n" \
"    const NOT_BOUNDED = 1;\n" \
"    const REQUEST_PLUS = 2;\n" \
"    const STATEMENT_PLUS = 3;\n" \
"\n" \
"    /**\n" \
"     * Creates a new N1qlQuery instance directly from a N1QL DML.\n" \
"     * @param $str\n" \
"     * @return CouchbaseN1qlQuery\n" \
"     */\n" \
"    static public function fromString($str) {\n" \
"        $res = new CouchbaseN1qlQuery();\n" \
"        $res->options['statement'] = $str;\n" \
"        $res->adhoc = true;\n" \
"        return $res;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Supply positional parameters for query.\n" \
"     *\n" \
"     * <code>\n" \
"     * $query = CouchbaseN1qlQuery::fromString('SELECT * FROM `travel-sample` WHERE city=$1 LIMIT $2');\n" \
"     * $query->positionalParams(array('New York', 3));\n" \
"     * </code>\n" \
"     *\n" \
"     * @param array $params\n" \
"     */\n" \
"    public function positionalParams($params) {\n" \
"        $this->options['args'] = $params;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Supply named parameters for query.\n" \
"     *\n" \
"     * <code>\n" \
"     * $query = CouchbaseN1qlQuery::fromString('SELECT * FROM `travel-sample` WHERE city=$city LIMIT $limit');\n" \
"     * $query->namedParams(array('city' => 'New York', 'limit' => 3));\n" \
"     * </code>\n" \
"     *\n" \
"     * @param array $params\n" \
"     */\n" \
"    public function namedParams($params) {\n" \
"        foreach ($params as $key => $value) {\n" \
"            $this->options['$' . $key] = $value;\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specify the consistency level for this query.\n" \
"     *\n" \
"     * @param $consistency\n" \
"     * @return $this\n" \
"     * @throws CouchbaseN1qlQuery\n" \
"     */\n" \
"    public function consistency($consistency) {\n" \
"        if ($consistency == self::NOT_BOUNDED) {\n" \
"            $this->options['scan_consistency'] = 'not_bounded';\n" \
"        } else if ($consistency == self::REQUEST_PLUS) {\n" \
"            $this->options['scan_consistency'] = 'request_plus';\n" \
"        } else if ($consistency == self::STATEMENT_PLUS) {\n" \
"            $this->options['scan_consistency'] = 'statement_plus';\n" \
"        } else {\n" \
"            throw new CouchbaseException('invalid option passed.');\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function consistentWith($mutationState) {\n" \
"        $this->options['scan_consistency'] = 'at_plus';\n" \
"        $this->options['scan_vectors'] = $mutationState->exportForN1ql();\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Specify whether this query is a one-time query, or if it\n" \
"     *   if it should be prepared.\n" \
"     *\n" \
"     * @param $adhoc\n" \
"     * @return $this\n" \
"     * @throws CouchbaseN1qlQuery\n" \
"     */\n" \
"    public function adhoc($adhoc) {\n" \
"        $this->adhoc = !!$adhoc;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Generates the N1QL object as it will be passed to the server.\n" \
"     *\n" \
"     * @return object\n" \
"     */\n" \
"    public function toObject() {\n" \
"        return $this->options;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Returns the string representation of this N1ql query (the statement).\n" \
"     *\n" \
"     * @return string\n" \
"     */\n" \
"    public function toString() {\n" \
"        return $this->options['statement'];\n" \
"    }\n" \
"}\n" \
""},
{"[CouchbaseNative]/CouchbaseSearchQuery.class.php","\n" \
"/**\n" \
" * File for the CouchbaseN1qlQuery class.\n" \
" */\n" \
"\n" \
"/**\n" \
" * Represents a Full Text Search query to be executed against a Couchbase bucket.\n" \
" *\n" \
" * @package Couchbase\n" \
" */\n" \
"class CouchbaseSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $indexName;\n" \
"\n" \
"    /**\n" \
"     * @var CouchbaseAbstractSearchQuery\n" \
"     */\n" \
"    private $queryPart;\n" \
"\n" \
"    /**\n" \
"     * @var integer\n" \
"     */\n" \
"    private $limit;\n" \
"\n" \
"    /**\n" \
"     * @var integer\n" \
"     */\n" \
"    private $skip;\n" \
"\n" \
"    /**\n" \
"     * @var boolean\n" \
"     */\n" \
"    private $explain;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $highlightStyle;\n" \
"\n" \
"    /**\n" \
"     * @var array\n" \
"     */\n" \
"    private $highlightFields;\n" \
"\n" \
"    /**\n" \
"     * @var integer\n" \
"     */\n" \
"    private $serverSideTimeout;\n" \
"\n" \
"    /**\n" \
"     * @var CouchbaseMutationState\n" \
"     */\n" \
"    private $mutationState;\n" \
"\n" \
"    /**\n" \
"     * @var array\n" \
"     */\n" \
"    private $fields;\n" \
"\n" \
"    /**\n" \
"     * @var array\n" \
"     */\n" \
"    private $facets = array();\n" \
"\n" \
"    public function __construct($indexName, $queryPart) {\n" \
"        $this->indexName = $indexName;\n" \
"        $this->queryPart = $queryPart;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Add a limit to the query on the number of hits it can return.\n" \
"     *\n" \
"     * @param integer $limit the maximum number of hits to return.\n" \
"     * @return $this\n" \
"     */\n" \
"    public function limit($limit) {\n" \
"        $this->limit = $limit;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Set the number of hits to skip (eg. for pagination).\n" \
"     *\n" \
"     * @param integer $skip the number of results to skip.\n" \
"     * @return $this\n" \
"     */\n" \
"    public function skip($skip) {\n" \
"        $this->skip = $skip;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Activates or deactivates the explanation of each result hit in the response, according to the parameter.\n" \
"     *\n" \
"     * @param boolean $explain should the response include an explanation of each hit (true) or not (false)?\n" \
"     * @return $this\n" \
"     */\n" \
"    public function explain($explain) {\n" \
"        $this->explain = $explain;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Configures the highlighting of matches in the response.\n" \
"     *\n" \
"     * This drives the inclusion of the fragments in each CouchbaseSearchQueryRow hit.\n" \
"     *\n" \
"     * Note that to be highlighted, the fields must be stored in the FTS index.\n" \
"     *\n" \
"     * @param string $style the style to apply ('ascii', 'html' or null).\n" \
"     * @param array $fields the optional fields on which to highlight. If none, all fields where there is a match are highlighted.\n" \
"     * @return $this\n" \
"     */\n" \
"    public function highlight($style, $fields = array()) {\n" \
"        if ($style != 'ascii' && $style != 'html') {\n" \
"            $this->highlightStyle = null;\n" \
"            $this->highlightFields = null;\n" \
"        } else {\n" \
"            $this->highlightStyle = $style;\n" \
"            if (count($fields) > 0) {\n" \
"                $this->highlightFields = $fields;\n" \
"            }\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Configures the list of fields for which the whole value should be included in the response. If empty, no field\n" \
"     * values are included.\n" \
"     *\n" \
"     * This drives the inclusion of the CouchbaseSearchQueryRow#fields() in each CouchbaseSearchQueryRow hit.\n" \
"     *\n" \
"     * Note that to be included, the fields must be stored in the FTS index.\n" \
"     *\n" \
"     * @param array fields\n" \
"     * @return $this\n" \
"     */\n" \
"    public function fields($fields = null) {\n" \
"        if ($fields) {\n" \
"            $this->fields = $fields;\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Sets the server side timeout.\n" \
"     *\n" \
"     * @param $timeout the server side timeout in milliseconds to apply.\n" \
"     * @return $this\n" \
"     */\n" \
"    public function serverSideTimeout($timeout) {\n" \
"        $this->serverSideTimeout = $timeout;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Adds one search facet to the query.\n" \
"     *\n" \
"     * This is an additive operation (the given facets are added to any facet previously requested),\n" \
"     * but if an existing facet has the same name it will be replaced.\n" \
"     *\n" \
"     * This drives the inclusion of the  facets in the CouchbaseSearchQueryResult.\n" \
"     *\n" \
"     * Note that to be faceted, a field's value must be stored in the FTS index.\n" \
"     *\n" \
"     * @param string $facetName the name of the facet to add (or replace if one already exists with same name).\n" \
"     * @param CouchbaseSearchFacet $facet the facet to add.\n" \
"     *\n" \
"     * @return $this\n" \
"     */\n" \
"    public function addFacet($facetName, $facet) {\n" \
"        if ($facet != null && $facetName != null) {\n" \
"            $this->facets[$facetName] = $facet;\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Clears all previously added CouchbaseSearchFacet\n" \
"     *\n" \
"     * @return $this\n" \
"     */\n" \
"    public function clearFacets() {\n" \
"        $this->facets = array();\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function consistentWith($mutationState) {\n" \
"        $this->mutationState = $mutationState;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function export() {\n" \
"        $result = array('indexName' => $this->indexName);\n" \
"        $this->injectParams($result);\n" \
"\n" \
"        $result['query'] = array();\n" \
"        $this->queryPart->injectParamsAndBoost($result['query']);\n" \
"        return $result;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        if ($this->limit !== null && $this->limit >= 0) {\n" \
"            $input['size'] = $this->limit;\n" \
"        }\n" \
"        if ($this->skip !== null && $this->skip >= 0) {\n" \
"            $input['from'] = $this->skip;\n" \
"        }\n" \
"        if ($this->explain !== null) {\n" \
"            $input['explain'] = $this->explain;\n" \
"        }\n" \
"        if ($this->highlightStyle !== null) {\n" \
"            $input['highlight'] = array('style' => $this->highlightStyle);\n" \
"            if (count($this->highlightFields) > 0) {\n" \
"                $input['highlight']['fields'] = $this->highlightFields;\n" \
"            }\n" \
"        }\n" \
"        if (count($this->fields) > 0) {\n" \
"            $input['fields'] = $this->fields;\n" \
"        }\n" \
"        if (count($this->facets) > 0) {\n" \
"            $facets = array();\n" \
"            foreach ($this->facets as $key => $value) {\n" \
"                $facets[$key] = array();\n" \
"                $value->injectParams($facets[$key]);\n" \
"            }\n" \
"            $input['facets'] = $facets;\n" \
"        }\n" \
"\n" \
"        $control = array();\n" \
"        //check need for timeout\n" \
"        if($this->serverSideTimeout !== null) {\n" \
"            $control['timeout'] = $this->serverSideTimeout;\n" \
"        }\n" \
"        if ($this->mutationState) {\n" \
"            $control['consistency'] = array(\n" \
"                'level' => 'at_plus',\n" \
"                'vectors' => array(\n" \
"                    $this->indexName => $this->mutationState->exportForSearch()\n" \
"                )\n" \
"            );\n" \
"        }\n" \
"        //if any control was set, inject it\n" \
"        if (count($control) > 0) {\n" \
"            $input['ctl'] = $control;\n" \
"        }\n" \
"    }\n" \
"\n" \
"    /* ===============================\n" \
"     * Factory methods for FTS queries\n" \
"     * =============================== */\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseStringSearchQuery body.\n" \
"     *\n" \
"     * @param string $query\n" \
"     */\n" \
"    public static function string($query) {\n" \
"        return new CouchbaseStringSearchQuery($query);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseMatchSearchQuery body.\n" \
"     *\n" \
"     * @param string $match\n" \
"     */\n" \
"    public static function match($match) {\n" \
"        return new CouchbaseMatchSearchQuery($match);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseMatchPhraseSearchQuery body.\n" \
"     *\n" \
"     * @param string $matchPhrase\n" \
"     */\n" \
"    public static function matchPhrase($matchPhrase) {\n" \
"        return new CouchbaseMatchPhraseSearchQuery($matchPhrase);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbasePrefixSearchQuery body.\n" \
"     *\n" \
"     * @param string $prefix\n" \
"     */\n" \
"    public static function prefix($prefix) {\n" \
"        return new CouchbasePrefixSearchQuery($prefix);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseRegexpSearchQuery body.\n" \
"     *\n" \
"     * @param string $regexp\n" \
"     */\n" \
"    public static function regexp($regexp) {\n" \
"        return new CouchbaseRegexpSearchQuery($regexp);\n" \
"    }\n" \
"\n" \
"    /** Prepare a CouchbaseNumericRangeSearchQuery body. */\n" \
"    public static function numericRange() {\n" \
"        return new CouchbaseNumericRangeSearchQuery();\n" \
"    }\n" \
"\n" \
"    /** Prepare a CouchbaseDateRangeSearchQuery body. */\n" \
"    public static function dateRange() {\n" \
"        return new CouchbaseDateRangeSearchQuery();\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseDisjunctionSearchQuery body.\n" \
"     *\n" \
"     * @param array $queries array of CouchbaseAbstractSearchQuery\n" \
"     */\n" \
"    public static function disjuncts($queries = array()) {\n" \
"        return new CouchbaseDisjunctionSearchQuery($queries);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseConjunctionSearchQuery body.\n" \
"     *\n" \
"     * @param array $queries array of CouchbaseAbstractSearchQuery\n" \
"     */\n" \
"    public static function conjuncts($queries = array()) {\n" \
"        return new CouchbaseConjunctionSearchQuery($queries);\n" \
"    }\n" \
"\n" \
"    /** Prepare a CouchbaseBooleanSearchQuery body. */\n" \
"    public static function booleans() {\n" \
"        return new CouchbaseBooleanSearchQuery();\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseWildcardSearchQuery body.\n" \
"     *\n" \
"     * @param string $wildcard\n" \
"     */\n" \
"    public static function wildcard($wildcard) {\n" \
"        return new CouchbaseWildcardSearchQuery($wildcard);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseDocIdSearchQuery body.\n" \
"     *\n" \
"     * @param array $docIds array of strings\n" \
"     */\n" \
"    public static function docId($docIds = array()) {\n" \
"        return new CouchbaseDocIdSearchQuery($docIds);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseBooleanFieldSearchQuery body.\n" \
"     *\n" \
"     * @param boolean $value\n" \
"     */\n" \
"    public static function booleanField($value) {\n" \
"        return new CouchbaseBooleanFieldSearchQuery($value);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbaseTermSearchQuery body.\n" \
"     *\n" \
"     * @param string $term\n" \
"     */\n" \
"    public static function term($term) {\n" \
"        return new CouchbaseTermSearchQuery($term);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepare a CouchbasePhraseSearchQuery body.\n" \
"     *\n" \
"     * @param array $terms array of strings\n" \
"     */\n" \
"    public static function phrase($terms) {\n" \
"        return new CouchbasePhraseSearchQuery($terms);\n" \
"    }\n" \
"\n" \
"    /** Prepare a CouchbaseMatchAllSearchQuery body. */\n" \
"    public static function matchAll() {\n" \
"        return new CouchbaseMatchAllSearchQuery();\n" \
"    }\n" \
"\n" \
"    /** Prepare a CouchbaseMatchNoneSearchQuery body. */\n" \
"    public static function matchNone() {\n" \
"        return new CouchbaseMatchNoneSearchQuery();\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A base class for all FTS query classes. Exposes the common FTS query parameters.\n" \
" * In order to instantiate various flavors of queries, look at concrete classes or\n" \
" * static factory methods in CouchbaseSearchQuery.\n" \
" */\n" \
"abstract class CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var double\n" \
"     */\n" \
"    private $boost;\n" \
"\n" \
"    protected function __construct() {\n" \
"        $this->boost = null;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        $this->boost = $boost;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParamsAndBoost(&$input) {\n" \
"        if ($this->boost !== null) {\n" \
"            $input['boost'] = $this->boost;\n" \
"        }\n" \
"        $this->injectParams($input);\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that performs a search according to the \"string query\" syntax.\n" \
" */\n" \
"class CouchbaseStringSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $query;\n" \
"\n" \
"    public function __construct($query) {\n" \
"        $this->query = $query;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['query'] = $this->query;\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches a given term, applying further processing to it\n" \
" * like analyzers, stemming and even #fuzziness(int).\n" \
" */\n" \
"class CouchbaseMatchSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $match;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $analyzer;\n" \
"\n" \
"    /**\n" \
"     * @var integer\n" \
"     */\n" \
"    private $prefixLength;\n" \
"\n" \
"    /**\n" \
"     * @var integer\n" \
"     */\n" \
"    private $fuzziness;\n" \
"\n" \
"    public function __construct($match) {\n" \
"        $this->match = $match;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function analyzer($analyzer) {\n" \
"        $this->analyzer = $analyzer;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function prefixLength($prefixLength) {\n" \
"        $this->prefixLength = $prefixLength;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function fuzziness($fuzziness) {\n" \
"        $this->fuzziness = $fuzziness;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['match'] = $this->match;\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"        if ($this->analyzer !== null) {\n" \
"            $input['analyzer'] = $this->analyzer;\n" \
"        }\n" \
"        if ($this->prefixLength !== null) {\n" \
"            $input['prefix_length'] = $this->prefixLength;\n" \
"        }\n" \
"        if ($this->fuzziness !== null) {\n" \
"            $input['fuzziness'] = $this->fuzziness;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches terms (without further analysis). Usually for debugging purposes.\n" \
" * Prefer using CouchbaseMatchSearchQuery.\n" \
" */\n" \
"class CouchbaseTermSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $term;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    /**\n" \
"     * @var integer\n" \
"     */\n" \
"    private $prefixLength;\n" \
"\n" \
"    /**\n" \
"     * @var integer\n" \
"     */\n" \
"    private $fuzziness;\n" \
"\n" \
"    public function __construct($term) {\n" \
"        $this->term = $term;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function prefixLength($prefixLength) {\n" \
"        $this->prefixLength = $prefixLength;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function fuzziness($fuzziness) {\n" \
"        $this->fuzziness = $fuzziness;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['term'] = $this->term;\n" \
"        if ($field != null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"        if ($fuzziness > 0) {\n" \
"            $input['fuzziness'] = $this->fuzziness;\n" \
"            if (prefixLength > 0) {\n" \
"                $input['prefix_length'] = $this->prefixLength;\n" \
"            }\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches several terms (a \"phrase\") as is. The order of the terms mater and no\n" \
" * further processing is applied to them, so they must appear in the index exactly as provided.\n" \
" * Usually for debugging purposes. Prefer CouchbaseMatchPhraseSearchQuery.\n" \
" */\n" \
"class CouchbasePhraseSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $terms;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    public function __construct($terms = array()) {\n" \
"        $this->terms = $terms;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        if (count($this->terms) < 1) {\n" \
"            throw new InvalidArgumentException(\"Phrase query must at least have one term\");\n" \
"        }\n" \
"        $input['terms'] = $this->terms;\n" \
"\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches several given terms (a \"phrase\"), applying further processing\n" \
" * like analyzers to them.\n" \
" */\n" \
"class CouchbaseMatchPhraseSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $matchPhrase;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $analyzer;\n" \
"\n" \
"    public function __construct($matchPhrase) {\n" \
"        $this->matchPhrase = $matchPhrase;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function analyzer($analyzer) {\n" \
"        $this->analyzer = $analyzer;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['match_phrase'] = $this->matchPhrase;\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"        if ($this->analyzer !== null) {\n" \
"            $input['analyzer'] = $this->analyzer;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that allows for simple matching on a given prefix.\n" \
" */\n" \
"class CouchbasePrefixSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $prefix;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    public function __construct($prefix) {\n" \
"        $this->prefix = $prefix;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['prefix'] = $this->prefix;\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that allows for simple matching of regular expressions.\n" \
" */\n" \
"class CouchbaseRegexpSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $regexp;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    public function __construct($regexp) {\n" \
"        $this->regexp = $regexp;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['regexp'] = $this->regexp;\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * An FTS query that allows for simple matching using wildcard characters (* and ?).\n" \
" */\n" \
"class CouchbaseWildcardSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $wildcard;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    public function __construct($wildcard) {\n" \
"        $this->wildcard = $wildcard;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['wildcard'] = $this->wildcard;\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that queries fields explicitly indexed as boolean.\n" \
" */\n" \
"class CouchbaseBooleanFieldSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var boolean\n" \
"     */\n" \
"    private $value;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    public function __construct($value) {\n" \
"        $this->value = $value;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['bool'] = $this->value;\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches on Couchbase document IDs. Useful to restrict the search space to a list of keys\n" \
" * (by using this in a compound query).\n" \
" */\n" \
"class CouchbaseDocIdSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var array\n" \
"     */\n" \
"    private $docIds;\n" \
"\n" \
"    public function __construct($docIds = array()) {\n" \
"        $this->docIds = $docIds;\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function docIds($docIds) {\n" \
"        foreach ($docIds as $docId) {\n" \
"            array_push($this->docIds, $field);\n" \
"        }\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        if (count($this->docIds) < 1) {\n" \
"            throw new InvalidArgumentException(\"DocID query needs at least one document ID\");\n" \
"        }\n" \
"\n" \
"        $input['ids'] = $this->docIds;\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches all indexed documents (usually for debugging purposes).\n" \
" */\n" \
"class CouchbaseMatchAllSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['match_all'] = null;\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches 0 document (usually for debugging purposes).\n" \
" */\n" \
"class CouchbaseMatchNoneSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['match_none'] = null;\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches documents on a range of values. At least one bound is required, and the\n" \
" * inclusiveness of each bound can be configured.\n" \
" */\n" \
"class CouchbaseNumericRangeSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var float\n" \
"     */\n" \
"    private $min;\n" \
"\n" \
"    /**\n" \
"     * @var float\n" \
"     */\n" \
"    private $max;\n" \
"\n" \
"    /**\n" \
"     * @var boolean\n" \
"     */\n" \
"    private $inclusiveMin;\n" \
"\n" \
"    /**\n" \
"     * @var boolean\n" \
"     */\n" \
"    private $inclusiveMax;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function min($min, $inclusive = true) {\n" \
"        $this->min = $min;\n" \
"        $this->inclusiveMin = $inclusive;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function max($max, $inclusive = false) {\n" \
"        $this->max = $max;\n" \
"        $this->inclusiveMax = $inclusive;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        if ($this->min === null && $this->max === null) {\n" \
"            throw new InvalidArgumentException(\"CouchbaseNumericRangeQuery needs at least one of min or max\");\n" \
"        }\n" \
"        if ($this->min !== null) {\n" \
"            $input['min'] = $this->min;\n" \
"            if ($this->inclusiveMin !== null) {\n" \
"                $input['inclusive_min'] = $this->inclusiveMin;\n" \
"            }\n" \
"        }\n" \
"        if ($this->max !== null) {\n" \
"            $input['max'] = $this->max;\n" \
"            if ($this->inclusiveMax !== null) {\n" \
"                $input['inclusive_max'] = $this->inclusiveMax;\n" \
"            }\n" \
"        }\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A FTS query that matches documents on a range of dates. At least one bound is required, and the parser\n" \
" * to use for the date (in string form) can be customized (see #dateTimeParser(string)).\n" \
" */\n" \
"class CouchbaseDateRangeSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $start;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $end;\n" \
"\n" \
"    /**\n" \
"     * @var boolean\n" \
"     */\n" \
"    private $inclusiveStart;\n" \
"\n" \
"    /**\n" \
"     * @var boolean\n" \
"     */\n" \
"    private $inclusiveEnd;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $dateTimeParser;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function field($field) {\n" \
"        $this->field = $field;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function start($start, $inclusive = true) {\n" \
"        $this->start = $start;\n" \
"        $this->inclusiveStart = $inclusive;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function end($end, $inclusive = false) {\n" \
"        $this->end = $end;\n" \
"        $this->inclusiveEnd = $inclusive;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * The name of the date/time parser to use to interpret #start(string) and #end(string).\n" \
"     */\n" \
"    public function dateTimeParser($parser) {\n" \
"        $this->dateTimeParser = $parser;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        if ($this->start === null && $this->end === null) {\n" \
"            throw new InvalidArgumentException(\"CouchbaseDateRangeQuery needs at least one of start or end\");\n" \
"        }\n" \
"        if ($this->start !== null) {\n" \
"            $input['start'] = $this->start;\n" \
"            if ($this->inclusiveStart !== null) {\n" \
"                $input['inclusive_start'] = $this->inclusiveStart;\n" \
"            }\n" \
"        }\n" \
"        if ($this->end !== null) {\n" \
"            $input['end'] = $this->end;\n" \
"            if ($this->inclusiveEnd !== null) {\n" \
"                $input['inclusive_end'] = $this->inclusiveEnd;\n" \
"            }\n" \
"        }\n" \
"        if ($this->dateTimeParser != null) {\n" \
"            $input['datetime_parser'] = $this->dateTimeParser;\n" \
"        }\n" \
"        if ($this->field !== null) {\n" \
"            $input['field'] = $this->field;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * Base class for FTS queries that are composite, compounding several other CouchbaseAbstractSearchQuery.\n" \
" */\n" \
"abstract class CouchbaseAbstractCompoundSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var array\n" \
"     */\n" \
"    protected $childQueries;\n" \
"\n" \
"    protected function __construct($childQueries) {\n" \
"        $this->childQueries = $childQueries;\n" \
"    }\n" \
"\n" \
"    protected function addAll($queries) {\n" \
"        foreach ($queries as $query) {\n" \
"            array_push($this->childQueries, $query);\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A compound FTS query that performs a logical OR between all its sub-queries (disjunction).\n" \
" * It requires that a minimum of the queries match. The minimum is configurable via #min(int) (default 1).\n" \
" */\n" \
"class CouchbaseDisjunctionSearchQuery extends CouchbaseAbstractCompoundSearchQuery {\n" \
"    /**\n" \
"     * @var int\n" \
"     */\n" \
"    private $min;\n" \
"\n" \
"    public function __construct($queries = array()) {\n" \
"        parent::__construct($queries);\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function min($min) {\n" \
"        $this->min = $min;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function either($queries) {\n" \
"        $this->addAll($queries);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        if (count($this->childQueries) < 1) {\n" \
"            throw new InvalidArgumentException(\"Compound query has no child query\");\n" \
"        }\n" \
"        if (count($this->childQueries) < $this->min) {\n" \
"            throw new InvalidArgumentException(\"Disjunction query as fewer children than the configured minimum \" + $this->min);\n" \
"        }\n" \
"\n" \
"        if ($this->min > 0) {\n" \
"            $input['min'] = $this->min;\n" \
"        }\n" \
"\n" \
"        $disjuncts = array();\n" \
"        foreach ($this->childQueries as $childQuery) {\n" \
"            $child = array();\n" \
"            $childQuery->injectParamsAndBoost($child);\n" \
"            array_push($disjuncts, $child);\n" \
"        }\n" \
"        $input['disjuncts'] = $disjuncts;\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A compound FTS query that performs a logical AND between all its sub-queries (conjunction).\n" \
" */\n" \
"class CouchbaseConjunctionSearchQuery extends CouchbaseAbstractCompoundSearchQuery {\n" \
"    public function __construct($queries = array()) {\n" \
"       parent::__construct($queries);\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function every($queries) {\n" \
"        $this->addAll($queries);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        if (count($this->childQueries) < 1) {\n" \
"            throw new InvalidArgumentException(\"Compound query has no child query\");\n" \
"        }\n" \
"\n" \
"        $conjuncts = array();\n" \
"        foreach ($this->childQueries as $childQuery) {\n" \
"            $child = array();\n" \
"            $childQuery->injectParamsAndBoost($child);\n" \
"            array_push($conjuncts, $child);\n" \
"        }\n" \
"        $input['conjuncts'] = $conjuncts;\n" \
"    }\n" \
"}\n" \
"\n" \
"/**\n" \
" * A compound FTS query that allows various combinations of sub-queries.\n" \
" */\n" \
"class CouchbaseBooleanSearchQuery extends CouchbaseAbstractSearchQuery {\n" \
"    /**\n" \
"     * @var CouchbaseConjunctionSearchQuery\n" \
"     */\n" \
"    private $must;\n" \
"\n" \
"    /**\n" \
"     * @var CouchbaseDisjunctionSearchQuery\n" \
"     */\n" \
"    private $mustNot;\n" \
"\n" \
"    /**\n" \
"     * @var CouchbaseDisjunctionSearchQuery\n" \
"     */\n" \
"    private $should;\n" \
"\n" \
"    public function __construct() {\n" \
"        $this->must = new CouchbaseConjunctionSearchQuery();\n" \
"        $this->mustNot = new CouchbaseDisjunctionSearchQuery();\n" \
"        $this->should = new CouchbaseDisjunctionSearchQuery();\n" \
"    }\n" \
"\n" \
"    public function boost($boost) {\n" \
"        parent::boost($boost);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function shouldMin($minForShould) {\n" \
"        $this->should->min($minForShould);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function must($mustQueries) {\n" \
"        $this->must->every($mustQueries);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function mustNot($mustNotQueries) {\n" \
"        $this->mustNot->either($mustNotQueries);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function should($shouldQueries) {\n" \
"        $this->should->either($shouldQueries);\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $mustIsEmpty = must === null || count($this->must->childQueries()) < 1;\n" \
"        $mustNotIsEmpty = mustNot === null || count($this->mustNot->childQueries()) < 1;\n" \
"        $shouldIsEmpty = should === null || count($this->should->childQueries()) < 1;\n" \
"\n" \
"        if ($mustIsEmpty && $mustNotIsEmpty && $shouldIsEmpty) {\n" \
"            throw new InvalidArgumentException(\"Boolean query needs at least one of must, mustNot and should\");\n" \
"        }\n" \
"\n" \
"        if (!$mustIsEmpty) {\n" \
"            $child = array();\n" \
"            $this->must->injectParamsAndBoost($child);\n" \
"            $input['must'] = $child;\n" \
"        }\n" \
"\n" \
"        if (!$mustNotIsEmpty) {\n" \
"            $child = array();\n" \
"            $this->mustNot->injectParamsAndBoost($child);\n" \
"            $input['must_not'] = $child;\n" \
"        }\n" \
"\n" \
"        if (!$shouldIsEmpty) {\n" \
"            $child = array();\n" \
"            $this->should->injectParamsAndBoost($child);\n" \
"            $input['should'] = $child;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"abstract class CouchbaseSearchFacet {\n" \
"    /**\n" \
"     * @var string\n" \
"     */\n" \
"    private $field;\n" \
"\n" \
"    /**\n" \
"     * @var integer\n" \
"     */\n" \
"    private $limit;\n" \
"\n" \
"    protected function __construct($field, $limit) {\n" \
"        $this->field = $field;\n" \
"        $this->limit = $limit;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        $input['size'] = $this->limit;\n" \
"        $input['field'] = $this->field;\n" \
"    }\n" \
"\n" \
"    public static function term($field, $limit) {\n" \
"        return new CouchbaseTermSearchFacet($field, $limit);\n" \
"    }\n" \
"\n" \
"    public static function numeric($field, $limit) {\n" \
"        return new CouchbaseNumericSearchFacet($field, $limit);\n" \
"    }\n" \
"\n" \
"    public static function dataRange($field, $limit) {\n" \
"        return new CouchbaseDateRangeSearchFacet($field, $limit);\n" \
"    }\n" \
"}\n" \
"\n" \
"class CouchbaseTermSearchFacet extends CouchbaseSearchFacet {\n" \
"    public function __construct($field, $limit) {\n" \
"        parent::__construct($field, $limit);\n" \
"    }\n" \
"}\n" \
"\n" \
"class CouchbaseDateRangeSearchFacet extends CouchbaseSearchFacet {\n" \
"    /**\n" \
"     * @var array\n" \
"     */\n" \
"    private $dateRanges;\n" \
"\n" \
"    public function __construct($field, $limit) {\n" \
"        parent::__construct($field, $limit);\n" \
"        $this->dateRanges = array();\n" \
"    }\n" \
"\n" \
"    public function addRange($rangeName, $start, $end) {\n" \
"        $range = array();\n" \
"        if ($start) {\n" \
"            $range['start'];\n" \
"        }\n" \
"        if ($end) {\n" \
"            $range['end'];\n" \
"        }\n" \
"        $this->dateRanges[$rangeName] = $range;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        parent::injectParams($input);\n" \
"        foreach ($this->dateRanges as $name => $value) {\n" \
"            $input['date_ranges'][$name] = $value;\n" \
"        }\n" \
"    }\n" \
"}\n" \
"\n" \
"class CouchbaseNumericRangeSearchFacet extends CouchbaseSearchFacet {\n" \
"    /**\n" \
"     * @var array\n" \
"     */\n" \
"    private $numericRanges;\n" \
"\n" \
"    public function __construct($field, $limit) {\n" \
"        parent::__construct($field, $limit);\n" \
"        $this->numericRanges = array();\n" \
"    }\n" \
"\n" \
"    public function addRange($rangeName, $min, $max) {\n" \
"        $range = array();\n" \
"        if ($min) {\n" \
"            $range['min'];\n" \
"        }\n" \
"        if ($max) {\n" \
"            $range['max'];\n" \
"        }\n" \
"        $this->numericRanges[$rangeName] = $range;\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function injectParams(&$input) {\n" \
"        parent::injectParams($input);\n" \
"        foreach ($this->numericRanges as $name => $value) {\n" \
"            $input['numeric_ranges'][$name] = $value;\n" \
"        }\n" \
"    }\n" \
"}\n" \
""},
{"[CouchbaseNative]/CouchbaseCluster.class.php","\n" \
"/**\n" \
" * File for the CouchbaseCluster class.\n" \
" *\n" \
" * @author Brett Lawson <brett19@gmail.com>\n" \
" */\n" \
"\n" \
"/**\n" \
" * Represents a cluster connection.\n" \
" *\n" \
" * @package Couchbase\n" \
" */\n" \
"class CouchbaseCluster {\n" \
"    /**\n" \
"     * @var _CouchbaseCluster\n" \
"     * @ignore\n" \
"     *\n" \
"     * Pointer to a manager instance if there is one.\n" \
"     */\n" \
"    private $_manager = NULL;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     * @ignore\n" \
"     *\n" \
"     * A cluster connection string to connect with.\n" \
"     */\n" \
"    private $_dsn;\n" \
"\n" \
"    private $authenticator;\n" \
"\n" \
"    /**\n" \
"     * Creates a connection to a cluster.\n" \
"     *\n" \
"     * Creates a CouchbaseCluster object and begins the bootstrapping\n" \
"     * process necessary for communications with the Couchbase Server.\n" \
"     *\n" \
"     * @param string $connstr A cluster connection string to connect with.\n" \
"     * @param string $username The username for the cluster.\n" \
"     * @param string $password The password for the cluster.\n" \
"     *\n" \
"     * @throws CouchbaseException\n" \
"     */\n" \
"    public function __construct($connstr = 'couchbase://127.0.0.1/', $username = '', $password = '') {\n" \
"        $this->_dsn = cbdsn_parse($connstr);\n" \
"    }\n" \
"\n" \
"    public function authenticate($authenticator) {\n" \
"        $this->authenticator = $authenticator;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Constructs a connection to a bucket.\n" \
"     *\n" \
"     * @param string $name The name of the bucket to open.\n" \
"     * @param string $password The bucket password to authenticate with.\n" \
"     * @return CouchbaseBucket A bucket object.\n" \
"     *\n" \
"     * @throws CouchbaseException\n" \
"     *\n" \
"     * @see CouchbaseBucket CouchbaseBucket\n" \
"     */\n" \
"    public function openBucket($name = 'default', $password = '') {\n" \
"        $bucketDsn = cbdsn_normalize($this->_dsn);\n" \
"        $bucketDsn['bucket'] = $name;\n" \
"        if (!$password && $this->authenticator) {\n" \
"            $password = $this->authenticator->getCredentials('bucket-kv', $name);\n" \
"        }\n" \
"        $dsnStr = cbdsn_stringify($bucketDsn);\n" \
"        return new CouchbaseBucket($dsnStr, $name, $password, $this->authenticator);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Creates a manager allowing the management of a Couchbase cluster.\n" \
"     *\n" \
"     * @param $username The administration username.\n" \
"     * @param $password The administration password.\n" \
"     * @return CouchbaseClusterManager\n" \
"     */\n" \
"    public function manager($username = '', $password = '') {\n" \
"        if (!$this->_manager) {\n" \
"            if (!($username && $password) && $this->authenticator) {\n" \
"                $credentials = $this->authenticator->getCredentials('cluster-mgmt');\n" \
"                $username = $credentials[0];\n" \
"                $password = $credentials[1];\n" \
"            }\n" \
"            if (!($username && $password)) {\n" \
"                throw new InvalidArgumentException('invalid credentials for cluster manager');\n" \
"            }\n" \
"            $this->_manager = new CouchbaseClusterManager(\n" \
"                cbdsn_stringify($this->_dsn), $username, $password);\n" \
"        }\n" \
"        return $this->_manager;\n" \
"    }\n" \
"}\n" \
"\n" \
"class CouchbaseAuthenticator {\n" \
"    private $adminUsername;\n" \
"    private $adminPassword;\n" \
"    private $buckets = array();\n" \
"\n" \
"    public function setBucketCredentials($bucketName, $password) {\n" \
"        $this->buckets[$bucketName] = $password;\n" \
"    }\n" \
"\n" \
"    public function setClusterCredentials($username, $password) {\n" \
"        $this->adminUsername = $username;\n" \
"        $this->adminPassword = $password;\n" \
"    }\n" \
"\n" \
"    public function getCredentials($context, $specific = null) {\n" \
"        switch ($context) {\n" \
"        case 'bucket-kv':\n" \
"            return $this->buckets[$specific];\n" \
"        case 'bucket-n1ql':\n" \
"            return $this->buckets[$specific];\n" \
"        case 'bucket-cbft':\n" \
"            return $this->buckets;\n" \
"        case 'cluster-n1ql':\n" \
"            return $this->buckets;\n" \
"        case 'cluster-mgmt':\n" \
"            return array($this->adminUsername, $this->adminPassword);\n" \
"        }\n" \
"        throw new InvalidArgumentException(\"unable to get '$context' credentials, specific: $specific\");\n" \
"    }\n" \
"}\n" \
""},
{"[CouchbaseNative]/CouchbaseClusterManager.class.php","\n" \
"/**\n" \
" * File for the CouchbaseClusterManager class.\n" \
" *\n" \
" * @author Brett Lawson <brett19@gmail.com>\n" \
" */\n" \
"\n" \
"/**\n" \
" * Class exposing the various available management operations that can be\n" \
" * performed on a cluster.\n" \
" *\n" \
" * @package Couchbase\n" \
" */\n" \
"class CouchbaseClusterManager {\n" \
"    /**\n" \
"     * @var _CouchbaseCluster\n" \
"     * @ignore\n" \
"     *\n" \
"     * Pointer to our C binding backing class.\n" \
"     */\n" \
"    private $_me;\n" \
"\n" \
"    /**\n" \
"     * Constructs a cluster manager connection.\n" \
"     *\n" \
"     * @param string $connstr A connection string to connect with.\n" \
"     * @param string $username The username to authenticate with.\n" \
"     * @param string $password The password to authenticate with.\n" \
"     *\n" \
"     * @private\n" \
"     * @ignore\n" \
"     */\n" \
"    public function __construct($connstr, $username, $password) {\n" \
"        $this->_me = new _CouchbaseCluster($connstr, $username, $password);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Lists all buckets on this cluster.\n" \
"     *\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function listBuckets() {\n" \
"        $path = \"/pools/default/buckets\";\n" \
"        $res = $this->_me->http_request(2, 1, $path, NULL, 2);\n" \
"        return json_decode($res, true);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Creates a new bucket on this cluster.\n" \
"     *\n" \
"     * @param string $name The bucket name.\n" \
"     * @param array $opts The options for this bucket.\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function createBucket($name, $opts = array()) {\n" \
"        $defaults = array(\n" \
"            'name' => $name,\n" \
"            'authType' => 'sasl',\n" \
"            'bucketType' => 'couchbase',\n" \
"            'ramQuotaMB' => 100,\n" \
"            'replicaNumber' => 1\n" \
"        );\n" \
"\n" \
"        $path = \"/pools/default/buckets\";\n" \
"        $body = http_build_query(array_merge($defaults, $opts));\n" \
"        $res = $this->_me->http_request(2, 2, $path, $body, 2);\n" \
"        return json_decode($res, true);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Deletes a bucket from the cluster.\n" \
"     *\n" \
"     * @param string $name\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function removeBucket($name) {\n" \
"        $path = \"/pools/default/buckets/\" . $name;\n" \
"        $res = $this->_me->http_request(2, 4, $path, NULL, 2);\n" \
"        return json_decode($res, true);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Retrieves cluster status information\n" \
"     *\n" \
"     * Returns an associative array of status information as seen\n" \
"     * on the cluster.  The exact structure of the returned data\n" \
"     * can be seen in the Couchbase Manual by looking at the\n" \
"     * cluster /info endpoint.\n" \
"     *\n" \
"     * @return mixed The status information.\n" \
"     *\n" \
"     * @throws CouchbaseException\n" \
"     */\n" \
"    public function info() {\n" \
"        $path = \"/pools/default\";\n" \
"        $res = $this->_me->http_request(2, 1, $path, NULL, 2);\n" \
"        return json_decode($res, true);\n" \
"    }\n" \
"}\n" \
""},
{"[CouchbaseNative]/CouchbaseBucket.class.php","\n" \
"/**\n" \
" * File for the CouchbaseBucket class.\n" \
" *\n" \
" * @author Brett Lawson <brett19@gmail.com>\n" \
" */\n" \
"\n" \
"/**\n" \
" * Represents a bucket connection.\n" \
" *\n" \
" * Note: This class must be constructed by calling the openBucket\n" \
" * method of the CouchbaseCluster class.\n" \
" *\n" \
" * @property integer $operationTimeout\n" \
" * @property integer $viewTimeout\n" \
" * @property integer $durabilityInterval\n" \
" * @property integer $durabilityTimeout\n" \
" * @property integer $httpTimeout\n" \
" * @property integer $configTimeout\n" \
" * @property integer $configDelay\n" \
" * @property integer $configNodeTimeout\n" \
" * @property integer $htconfigIdleTimeout\n" \
" *\n" \
" * @package Couchbase\n" \
" *\n" \
" * @see CouchbaseCluster::openBucket()\n" \
" */\n" \
"class CouchbaseBucket {\n" \
"    /**\n" \
"     * @var _CouchbaseBucket\n" \
"     * @ignore\n" \
"     *\n" \
"     * Pointer to our C binding backing class.\n" \
"     */\n" \
"    private $me;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     * @ignore\n" \
"     *\n" \
"     * The name of the bucket this object represents.\n" \
"     */\n" \
"    private $name;\n" \
"\n" \
"    /**\n" \
"     * @var _CouchbaseCluster\n" \
"     * @ignore\n" \
"     *\n" \
"     * Pointer to a manager instance if there is one.\n" \
"     */\n" \
"    private $_manager;\n" \
"\n" \
"    /**\n" \
"     * @var array\n" \
"     * @ignore\n" \
"     *\n" \
"     * A list of N1QL nodes to query.\n" \
"     */\n" \
"    private $queryhosts = NULL;\n" \
"\n" \
"    private $authenticator;\n" \
"\n" \
"    /**\n" \
"     * Constructs a bucket connection.\n" \
"     *\n" \
"     * @private\n" \
"     * @ignore\n" \
"     *\n" \
"     * @param string $connstr A cluster connection string to connect with.\n" \
"     * @param string $name The name of the bucket to connect to.\n" \
"     * @param string $password The password to authenticate with.\n" \
"     *\n" \
"     * @private\n" \
"     */\n" \
"    public function __construct($connstr, $name, $password, $authenticator = null) {\n" \
"        $this->me = new _CouchbaseBucket($connstr, $name, $password);\n" \
"        $this->me->setTranscoder(\"couchbase_default_encoder\", \"couchbase_default_decoder\");\n" \
"        $this->name = $name;\n" \
"        $this->authenticator = $authenticator;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Returns bucket name\n" \
"     *\n" \
"     * @return string name of the bucket\n" \
"     */\n" \
"    public function getName()\n" \
"    {\n" \
"        return $this->name;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Returns an instance of a CouchbaseBucketManager for performing management\n" \
"     * operations against a bucket.\n" \
"     *\n" \
"     * @return CouchbaseBucketManager\n" \
"     */\n" \
"    public function manager() {\n" \
"        if (!$this->_manager) {\n" \
"            $this->_manager = new CouchbaseBucketManager(\n" \
"                $this->me, $this->name);\n" \
"        }\n" \
"        return $this->_manager;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Enables N1QL support on the client.  A cbq-server URI must be passed.\n" \
"     * This method will be deprecated in the future in favor of automatic\n" \
"     * configuration through the connected cluster.\n" \
"     *\n" \
"     * @param $hosts An array of host/port combinations which are N1QL servers\n" \
"     * attached to the cluster.\n" \
"     */\n" \
"    public function enableN1ql($hosts) {\n" \
"        if (is_array($hosts)) {\n" \
"            $this->queryhosts = $hosts;\n" \
"        } else {\n" \
"            $this->queryhosts = array($hosts);\n" \
"        }\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Inserts a document.  This operation will fail if\n" \
"     * the document already exists on the cluster.\n" \
"     *\n" \
"     * @param string|array $ids\n" \
"     * @param mixed $val\n" \
"     * @param array $options expiry(integer), persist_to(integer), replicate_to(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function insert($ids, $val = NULL, $options = array()) {\n" \
"        return $this->me->insert($ids, $val, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Inserts or updates a document, depending on whether the\n" \
"     * document already exists on the cluster.\n" \
"     *\n" \
"     * @param string|array $ids\n" \
"     * @param mixed $val\n" \
"     * @param array $options expiry(integer), persist_to(integer), replicate_to(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function upsert($ids, $val = NULL, $options = array()) {\n" \
"        return $this->me->upsert($ids, $val, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Replaces a document.\n" \
"     *\n" \
"     * @param string|array $ids\n" \
"     * @param mixed $val\n" \
"     * @param array $options cas(string), expiry(integer), persist_to(integer), replicate_to(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function replace($ids, $val = NULL, $options = array()) {\n" \
"        return $this->me->replace($ids, $val, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Appends content to a document.\n" \
"     *\n" \
"     * @param string|array $ids\n" \
"     * @param mixed $val\n" \
"     * @param array $options cas(string), persist_to(integer), replicate_to(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function append($ids, $val = NULL, $options = array()) {\n" \
"        return $this->me->append($ids, $val, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Prepends content to a document.\n" \
"     *\n" \
"     * @param string|array $ids\n" \
"     * @param mixed $val\n" \
"     * @param array $options cas(string), persist_to(integer), replicate_to(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function prepend($ids, $val = NULL, $options = array()) {\n" \
"        return $this->me->prepend($ids, $val, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Deletes a document.\n" \
"     *\n" \
"     * @param string|array $ids\n" \
"     * @param array $options cas(string), persist_to(integer), replicate_to(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function remove($ids, $options = array()) {\n" \
"        return $this->_endure($ids, $options,\n" \
"            $this->me->remove(is_array($ids) ? array_unique($ids) : $ids, $options));\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Retrieves a document.\n" \
"     *\n" \
"     * @param string|array $ids\n" \
"     * @param array $options lock(integer), expiry(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function get($ids, $options = array()) {\n" \
"        return $this->me->get(is_array($ids) ? array_unique($ids) : $ids, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Retrieves a document and simultaneously updates its expiry.\n" \
"     *\n" \
"     * @param string $id\n" \
"     * @param integer $expiry\n" \
"     * @param array $options\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function getAndTouch($id, $expiry, $options = array()) {\n" \
"        $options['expiry'] = $expiry;\n" \
"        return $this->me->get($id, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Retrieves a document and locks it.\n" \
"     *\n" \
"     * @param string $id\n" \
"     * @param integer $lockTime\n" \
"     * @param array $options\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function getAndLock($id, $lockTime, $options = array()) {\n" \
"        $options['lockTime'] = $lockTime;\n" \
"        return $this->me->get($id, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Retrieves a document from a replica.\n" \
"     *\n" \
"     * @param string $id\n" \
"     * @param array $options index(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function getFromReplica($id, $options = array()) {\n" \
"        return $this->me->getFromReplica($id, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Updates a documents expiry.\n" \
"     *\n" \
"     * @param string $id\n" \
"     * @param integer $expiry\n" \
"     * @param array $options\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function touch($id, $expiry, $options = array()) {\n" \
"        return $this->me->touch($id, $expiry, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Increment or decrements a key (based on $delta).\n" \
"     *\n" \
"     * @param string|array $ids\n" \
"     * @param integer $delta\n" \
"     * @param array $options initial(integer), expiry(integer)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function counter($ids, $delta, $options = array()) {\n" \
"        return $this->_endure($ids, $options,\n" \
"            $this->me->counter($ids, $delta, $options));\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Unlocks a key previous locked with a call to get().\n" \
"     * @param string|array $ids\n" \
"     * @param array $options cas(string)\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function unlock($ids, $options = array()) {\n" \
"        return $this->me->unlock(is_array($ids) ? array_unique($ids) : $ids, $options);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Executes a view query.\n" \
"     *\n" \
"     * @param ViewQuery $queryObj\n" \
"     * @return mixed\n" \
"     * @throws CouchbaseException\n" \
"     *\n" \
"     * @internal\n" \
"     */\n" \
"    public function _view($queryObj, $json_asarray) {\n" \
"        $path = $queryObj->toString();\n" \
"        $res = $this->me->http_request(1, 1, $path, NULL, 1);\n" \
"        $out = json_decode($res, $json_asarray);\n" \
"        if ($json_asarray) {\n" \
"            if (isset($out['error'])) {\n" \
"                throw new CouchbaseException($out['error'] . ': ' . $out['reason']);\n" \
"            }\n" \
"        } else {\n" \
"            if (isset($out->error)) {\n" \
"                throw new CouchbaseException($out->error . ': ' . $out->reason);\n" \
"            }\n" \
"        }\n" \
"        return $out;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Performs a N1QL query.\n" \
"     *\n" \
"     * @param CouchbaseN1qlQuery $queryObj\n" \
"     * @return mixed\n" \
"     * @throws CouchbaseException\n" \
"     *\n" \
"     * @internal\n" \
"     */\n" \
"    public function _n1ql($queryObj, $json_asarray) {\n" \
"        $data = $queryObj->options;\n" \
"        $dataStr = json_encode($data, true);\n" \
"        $dataOut = $this->me->n1ql_request($dataStr, $queryObj->adhoc);\n" \
"\n" \
"        $meta = json_decode($dataOut['meta'], true);\n" \
"        if (isset($meta['errors']) && count($meta['errors']) > 0) {\n" \
"            $err = $meta['errors'][0];\n" \
"            $ex = new CouchbaseException($err['msg']);\n" \
"            $ex->qCode = $err['code'];\n" \
"            throw $ex;\n" \
"        }\n" \
"\n" \
"        $rows = array();\n" \
"        foreach ($dataOut['results'] as $row) {\n" \
"            $rows[] = json_decode($row, $json_asarray);\n" \
"        }\n" \
"        $result = array(\n" \
"            'rows' => $rows,\n" \
"            'status' => $meta['status'],\n" \
"            'metrics' => $meta['metrics']\n" \
"        );\n" \
"\n" \
"        if ( ! $json_asarray) {\n" \
"            return (object)$result;\n" \
"        }\n" \
"\n" \
"        return $result;\n" \
"    }\n" \
"\n" \
"    public function _search($queryObj, $json_asarray) {\n" \
"        $dataIn = json_encode($queryObj->export());\n" \
"        $dataOut = $this->me->fts_request($dataIn);\n" \
"\n" \
"        $meta = json_decode($dataOut['meta'], true);\n" \
"        if (isset($meta['errors']) && count($meta['errors']) > 0) {\n" \
"            throw new CouchbaseException(json_encode($meta['errors']));\n" \
"        }\n" \
"\n" \
"        $hits = array();\n" \
"        foreach ($dataOut['results'] as $row) {\n" \
"            $hits[] = json_decode($row, $json_asarray);\n" \
"        }\n" \
"        $result = array(\n" \
"            'hits' => $hits,\n" \
"            'status' => $meta['status'],\n" \
"            'metrics' => array(\n" \
"                'total_hits' => $meta['total_hits'],\n" \
"                'took' => $meta['took'],\n" \
"                'max_score' => $meta['max_score']\n" \
"            )\n" \
"        );\n" \
"        if (isset($meta['facets'])) {\n" \
"            $result['facets'] = $meta['facets'];\n" \
"        }\n" \
"\n" \
"        if ( ! $json_asarray) {\n" \
"            return (object)$result;\n" \
"        }\n" \
"\n" \
"        return $result;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Performs a query (either ViewQuery or N1qlQuery).\n" \
"     *\n" \
"     * @param CouchbaseQuery $query\n" \
"     * @return mixed\n" \
"     * @throws CouchbaseException\n" \
"     */\n" \
"    public function query($query, $json_asarray = false) {\n" \
"        if ($query instanceof _CouchbaseDefaultViewQuery ||\n" \
"            $query instanceof _CouchbaseSpatialViewQuery) {\n" \
"            return $this->_view($query, $json_asarray);\n" \
"        } else if ($query instanceof CouchbaseN1qlQuery) {\n" \
"            return $this->_n1ql($query, $json_asarray);\n" \
"        } else if ($query instanceof CouchbaseSearchQuery) {\n" \
"            return $this->_search($query, $json_asarray);\n" \
"        } else {\n" \
"            throw new CouchbaseException(\n" \
"                'Passed object must be of type ViewQuery, N1qlQuery or SearchQuery');\n" \
"        }\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Creates a CouchbaseLookupInBuilder object with which you can then use method-chaining\n" \
"     * to populate them with lookup operations and then later execute.\n" \
"     *\n" \
"     * @param string $id\n" \
"     * @return CouchbaseLookupInBuilder\n" \
"     */\n" \
"    public function lookupIn($id) {\n" \
"        return new CouchbaseLookupInBuilder($this, $id);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Shortcut to alternative to constructing a builder for getting multiple\n" \
"     * paths in the document.\n" \
"     *\n" \
"     * @param string $id\n" \
"     * @param string ...$keys\n" \
"     */\n" \
"    public function retrieveIn($id) {\n" \
"        $builder = new CouchbaseLookupInBuilder($this, $id);\n" \
"        $args = func_get_args();\n" \
"        for ($i = 1; $i < func_num_args(); $i++) {\n" \
"            $builder->get($args[$i]);\n" \
"        }\n" \
"        return $builder->execute();\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Creates a CouchbaseMutateInBuilder object with which you can then use method-chaining\n" \
"     * to populate them with mutation operations and then later execute.\n" \
"     *\n" \
"     * @param string $id\n" \
"     * @param string $cas\n" \
"     * @return CouchbaseMutateInBuilder\n" \
"     */\n" \
"    public function mutateIn($id, $cas = null) {\n" \
"        return new CouchbaseMutateInBuilder($this, $id, $cas);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Function, which performs subdocument calls\n" \
"     *\n" \
"     * @internal\n" \
"     *\n" \
"     * @param string $id\n" \
"     * @param array $commands list of commands from builder\n" \
"     * @param string $cas CAS value for mutations\n" \
"     */\n" \
"    public function _subdoc($id, $commands, $cas = null) {\n" \
"        return $this->me->subdoc_request($id, $commands, $cas);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Sets custom encoder and decoder functions for handling serialization.\n" \
"     *\n" \
"     * @param string $encoder The encoder function name\n" \
"     * @param string $decoder The decoder function name\n" \
"     */\n" \
"    public function setTranscoder($encoder, $decoder) {\n" \
"        return $this->me->setTranscoder($encoder, $decoder);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Ensures durability requirements are met for an executed\n" \
"     *  operation.  Note that this function will automatically\n" \
"     *  determine the result types and check for any failures.\n" \
"     *\n" \
"     * @private\n" \
"     * @ignore\n" \
"     *\n" \
"     * @param $id\n" \
"     * @param $res\n" \
"     * @param $options\n" \
"     * @return mixed\n" \
"     * @throws Exception\n" \
"     */\n" \
"    private function _endure($id, $options, $res) {\n" \
"        if ((!isset($options['persist_to']) || !$options['persist_to']) &&\n" \
"            (!isset($options['replicate_to']) || !$options['replicate_to'])) {\n" \
"            return $res;\n" \
"        }\n" \
"        if (is_array($res)) {\n" \
"            // Build list of keys to check\n" \
"            $chks = array();\n" \
"            foreach ($res as $key => $result) {\n" \
"                if (!$result->error) {\n" \
"                    $chks[$key] = array(\n" \
"                        'cas' => $result->cas\n" \
"                    );\n" \
"                }\n" \
"            }\n" \
"\n" \
"            // Do the checks\n" \
"            $dres = $this->me->durability($chks, array(\n" \
"                'persist_to' => $options['persist_to'],\n" \
"                'replicate_to' => $options['replicate_to']\n" \
"            ));\n" \
"\n" \
"            // Copy over the durability errors\n" \
"            foreach ($dres as $key => $result) {\n" \
"                if (!$result) {\n" \
"                    $res[$key]->error = $result->error;\n" \
"                }\n" \
"            }\n" \
"\n" \
"            return $res;\n" \
"        } else {\n" \
"            if ($res->error) {\n" \
"                return $res;\n" \
"            }\n" \
"\n" \
"            $dres = $this->me->durability($id, array(\n" \
"                'cas' => $res->cas,\n" \
"                'persist_to' => $options['persist_to'],\n" \
"                'replicate_to' => $options['replicate_to']\n" \
"            ));\n" \
"\n" \
"            return $res;\n" \
"        }\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Magic function to handle the retrieval of various properties.\n" \
"     *\n" \
"     * @internal\n" \
"     */\n" \
"    public function __get($name) {\n" \
"        if ($name == 'operationTimeout') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_OP_TIMEOUT);\n" \
"        } else if ($name == 'viewTimeout') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_VIEW_TIMEOUT);\n" \
"        } else if ($name == 'durabilityInterval') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_DURABILITY_INTERVAL);\n" \
"        } else if ($name == 'durabilityTimeout') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_DURABILITY_TIMEOUT);\n" \
"        } else if ($name == 'httpTimeout') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_HTTP_TIMEOUT);\n" \
"        } else if ($name == 'configTimeout') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_CONFIGURATION_TIMEOUT);\n" \
"        } else if ($name == 'configDelay') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_CONFDELAY_THRESH);\n" \
"        } else if ($name == 'configNodeTimeout') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_CONFIG_NODE_TIMEOUT);\n" \
"        } else if ($name == 'htconfigIdleTimeout') {\n" \
"            return $this->me->getOption(COUCHBASE_CNTL_HTCONFIG_IDLE_TIMEOUT);\n" \
"        }\n" \
"\n" \
"        $trace = debug_backtrace();\n" \
"        trigger_error(\n" \
"            'Undefined property via __get(): ' . $name .\n" \
"            ' in ' . $trace[0]['file'] .\n" \
"            ' on line ' . $trace[0]['line'],\n" \
"            E_USER_NOTICE);\n" \
"        return null;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Magic function to handle the setting of various properties.\n" \
"     *\n" \
"     * @internal\n" \
"     */\n" \
"    public function __set($name, $value) {\n" \
"        if ($name == 'operationTimeout') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_OP_TIMEOUT, $value);\n" \
"        } else if ($name == 'viewTimeout') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_VIEW_TIMEOUT, $value);\n" \
"        } else if ($name == 'durabilityInterval') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_DURABILITY_INTERVAL, $value);\n" \
"        } else if ($name == 'durabilityTimeout') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_DURABILITY_TIMEOUT, $value);\n" \
"        } else if ($name == 'httpTimeout') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_HTTP_TIMEOUT, $value);\n" \
"        } else if ($name == 'configTimeout') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_CONFIGURATION_TIMEOUT, $value);\n" \
"        } else if ($name == 'configDelay') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_CONFDELAY_THRESH, $value);\n" \
"        } else if ($name == 'configNodeTimeout') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_CONFIG_NODE_TIMEOUT, $value);\n" \
"        } else if ($name == 'htconfigIdleTimeout') {\n" \
"            return $this->me->setOption(COUCHBASE_CNTL_HTCONFIG_IDLE_TIMEOUT, $value);\n" \
"        }\n" \
"\n" \
"        $trace = debug_backtrace();\n" \
"        trigger_error(\n" \
"            'Undefined property via __set(): ' . $name .\n" \
"            ' in ' . $trace[0]['file'] .\n" \
"            ' on line ' . $trace[0]['line'],\n" \
"            E_USER_NOTICE);\n" \
"        return null;\n" \
"    }\n" \
"}\n" \
"\n" \
"class CouchbaseMutationState {\n" \
"    /**\n" \
"     * @var array\n" \
"     */\n" \
"    private $tokens = array();\n" \
"\n" \
"    public static function from($source = array()) {\n" \
"        $state = new CouchbaseMutationState();\n" \
"        $state->add($source);\n" \
"        return $state;\n" \
"    }\n" \
"\n" \
"    public function add($source = array()) {\n" \
"        if (count($source) < 1) {\n" \
"            throw new InvalidArgumentException(\"At least one document or fragment must be provided\");\n" \
"        }\n" \
"        foreach ($source as $doc) {\n" \
"            $this->addToken($doc->token);\n" \
"        }\n" \
"    }\n" \
"\n" \
"    public function exportForN1ql() {\n" \
"        $result = array();\n" \
"        foreach ($this->tokens as $token) {\n" \
"            if (!array_key_exists($token->bucket, $this->tokens)) {\n" \
"                $result[$token->bucket] = array();\n" \
"            }\n" \
"            $bucket = &$result[$token->bucket];\n" \
"            $bucket[$token->vbucketID] = array($token->sequenceNumber, $token->vbucketUUID);\n" \
"        }\n" \
"        return $result;\n" \
"    }\n" \
"\n" \
"    public function exportForSearch() {\n" \
"        $result = array();\n" \
"        foreach ($this->tokens as $token) {\n" \
"            $tokenKey = $token->vbucketID . '/' . $token->vbucketUUID;\n" \
"            $oldSeqno = $result[$tokenKey];\n" \
"            if ($oldSeqno < $token->sequenceNumber) {\n" \
"                $result[$tokenKey] = $token->sequenceNumber;\n" \
"            }\n" \
"        }\n" \
"        return $result;\n" \
"    }\n" \
"\n" \
"    private function addToken($newToken) {\n" \
"        for ($i = 0; $i < count($this->tokens); $i++) {\n" \
"            $token = $this->tokens[$i];\n" \
"            if ($token->vbucketID == $newToken->vbucketID && $token->bucket == $newToken->bucket) {\n" \
"                $this->tokens[$i] = $newToken;\n" \
"                return;\n" \
"            }\n" \
"        }\n" \
"        array_push($this->tokens, $newToken);\n" \
"    }\n" \
"}\n" \
""},
{"[CouchbaseNative]/CouchbaseBucketManager.class.php","\n" \
"/**\n" \
" * File for the CouchbaseBucketManager class.\n" \
" * @author Brett Lawson <brett19@gmail.com>\n" \
" */\n" \
"\n" \
"/**\n" \
" * Class exposing the various available management operations that can be\n" \
" * performed on a bucket.\n" \
" *\n" \
" * @package Couchbase\n" \
" */\n" \
"class CouchbaseBucketManager {\n" \
"    /**\n" \
"     * @var _CouchbaseBucket\n" \
"     * @ignore\n" \
"     *\n" \
"     * Pointer to our C binding backing class.\n" \
"     */\n" \
"    private $_me;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     * @ignore\n" \
"     *\n" \
"     * Name of the bucket we are managing\n" \
"     */\n" \
"    private $_name;\n" \
"\n" \
"    /**\n" \
"     * @private\n" \
"     * @ignore\n" \
"     *\n" \
"     * @param $binding\n" \
"     * @param $name\n" \
"     */\n" \
"    public function __construct($binding, $name) {\n" \
"        $this->_me = $binding;\n" \
"        $this->_name = $name;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Returns all the design documents for this bucket.\n" \
"     *\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function getDesignDocuments() {\n" \
"        $path = \"/pools/default/buckets/\" . $this->_name . '/ddocs';\n" \
"        $res = $this->_me->http_request(2, 1, $path, NULL, 2);\n" \
"        $ddocs = array();\n" \
"        $data = json_decode($res, true);\n" \
"        foreach ($data['rows'] as $row) {\n" \
"            $name = substr($row['doc']['meta']['id'], 8);\n" \
"            $ddocs[$name] = $row['doc']['json'];\n" \
"        }\n" \
"        return $ddocs;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Inserts a design document to this bucket.  Failing if a design\n" \
"     * document with the same name already exists.\n" \
"     *\n" \
"     * @param $name Name of the design document.\n" \
"     * @param $data The design document data.\n" \
"     * @throws CouchbaseException\n" \
"     * @returns true\n" \
"     */\n" \
"    public function insertDesignDocument($name, $data) {\n" \
"        if ($this->getDesignDocument($name)) {\n" \
"            throw new CouchbaseException('design document already exists');\n" \
"        }\n" \
"        return $this->upsertDesignDocument($name, $data);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Inserts a design document to this bucket.  Overwriting any existing\n" \
"     * design document with the same name.\n" \
"     *\n" \
"     * @param $name Name of the design document.\n" \
"     * @param $data The design document data.\n" \
"     * @returns true\n" \
"     */\n" \
"    public function upsertDesignDocument($name, $data) {\n" \
"        $path = '_design/' . $name;\n" \
"        $res = $this->_me->http_request(1, 3, $path, json_encode($data), 1);\n" \
"        $data = json_decode($res, true);\n" \
"        if (isset($data['error'])) {\n" \
"            throw new CouchbaseException($data['reason']);\n" \
"        }\n" \
"        return true;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Retrieves a design documents from the bucket.\n" \
"     *\n" \
"     * @param $name Name of the design document.\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function getDesignDocument($name) {\n" \
"        $path = '_design/' . $name;\n" \
"        $res = $this->_me->http_request(1, 1, $path, NULL, 2);\n" \
"        $data = json_decode($res, true);\n" \
"        if (isset($data['error'])) {\n" \
"            return false;\n" \
"        }\n" \
"        return $data;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Deletes a design document from the bucket.\n" \
"     *\n" \
"     * @param $name Name of the design document.\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function removeDesignDocument($name) {\n" \
"        $path = '_design/' . $name;\n" \
"        $res = $this->_me->http_request(1, 4, $path, NULL, 2);\n" \
"        return json_decode($res, true);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * List all N1QL indexes that are registered for the current bucket.\n" \
"     */\n" \
"    public function listN1qlIndexes() {\n" \
"        return $this->_me->n1ix_list();\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Create a primary N1QL index.\n" \
"     *\n" \
"     * @param string $customName the custom name for the primary index.\n" \
"     * @param boolean $ignoreIfExist if a primary index already exists, an exception will be thrown unless this is set\n" \
"     *                               to true.\n" \
"     * @param boolean $defer true to defer building of the index until buildN1qlDeferredIndexes()}is called (or a direct\n" \
"     *                       call to the corresponding query service API).\n" \
"     */\n" \
"    public function createN1qlPrimaryIndex($customName = '', $ignoreIfExist = false, $defer = false) {\n" \
"        return $this->_me->n1ix_create($customName, '', '', $ignoreIfExist, $defer, true);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Create a secondary index for the current bucket.\n" \
"     *\n" \
"     * @param string $indexName the name of the index.\n" \
"     * @param array $fields the JSON fields to index.\n" \
"     * @param string $whereClause the WHERE clause of the index.\n" \
"     * @param boolean $ignoreIfExist if a secondary index already exists with that name, an exception will be thrown\n" \
"     *                               unless this is set to true.\n" \
"     * @param boolean $defer true to defer building of the index until buildN1qlDeferredIndexes() is called (or a direct\n" \
"     *                       call to the corresponding query service API).\n" \
"     */\n" \
"    public function createN1qlIndex($indexName, $fields, $whereClause = '', $ignoreIfExist = false, $defer = false) {\n" \
"        return $this->_me->n1ix_create($indexName, json_encode($fields), $whereClause, $ignoreIfExist, $defer, false);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Drop the given primary index associated with the current bucket.\n" \
"     *\n" \
"     * @param string $customName the custom name of the primary index or empty string for default.\n" \
"     * @param boolean $ignoreIfNotExist if true, attempting to drop on a bucket without any primary index won't cause an\n" \
"     *                                  exception to be propagated.\n" \
"     */\n" \
"    public function dropN1qlPrimaryIndex($customName = '', $ignoreIfNotExist = false) {\n" \
"        return $this->_me->n1ix_drop($customName, $ignoreIfNotExist, true);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Drop the given secondary index associated with the current bucket.\n" \
"     *\n" \
"     * @param string $indexName the name of the index.\n" \
"     * @param boolean $ignoreIfNotExist if true, attempting to drop on a bucket without any primary index won't cause an\n" \
"     *                                  exception to be propagated.\n" \
"     */\n" \
"    public function dropN1qlIndex($indexName, $ignoreIfNotExist = false) {\n" \
"        return $this->_me->n1ix_drop($indexName, $ignoreIfNotExist, false);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Flushes this bucket (clears all data).\n" \
"     *\n" \
"     * @return mixed\n" \
"     */\n" \
"    public function flush() {\n" \
"        $path = \"/pools/default/buckets/\" . $this->_name . \"/controller/doFlush\";\n" \
"        $res = $this->_me->http_request(2, 2, $path, NULL, 2);\n" \
"        return json_decode($res, true);\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Retrieves bucket status information\n" \
"     *\n" \
"     * Returns an associative array of status information as seen\n" \
"     * by the cluster for this bucket.  The exact structure of the\n" \
"     * returned data can be seen in the Couchbase Manual by looking\n" \
"     * at the bucket /info endpoint.\n" \
"     *\n" \
"     * @return mixed The status information.\n" \
"     */\n" \
"    public function info()\n" \
"    {\n" \
"        $path = \"/pools/default/buckets/\" . $this->_name;\n" \
"        $res = $this->_me->http_request(2, 1, $path, NULL, 2);\n" \
"        return json_decode($res, true);\n" \
"    }\n" \
"}\n" \
""},
{"[CouchbaseNative]/CouchbaseMutateInBuilder.class.php","\n" \
"/**\n" \
" * File for the CouchbaseMutateInBuilder class.\n" \
" *\n" \
" * @author Sergey Avseyev <sergey.avseyev@gmail.com>\n" \
" */\n" \
"\n" \
"/**\n" \
" * Represents a builder for subdocument mutation command.\n" \
" *\n" \
" * Note: This class must be constructed by calling the mutateIn()\n" \
" * method of the CouchbaseBucket class.\n" \
" *\n" \
" * @property integer $id\n" \
" *\n" \
" * @package Couchbase\n" \
" *\n" \
" * @see CouchbaseBucket::mutateIn()\n" \
" */\n" \
"class CouchbaseMutateInBuilder {\n" \
"    /**\n" \
"     * @var string\n" \
"     *\n" \
"     * Unique identifier for the document\n" \
"     */\n" \
"    public $id;\n" \
"\n" \
"    /**\n" \
"     * @var string\n" \
"     *\n" \
"     * Unique and opaque value which identifies current state\n" \
"     * of the document and regenerated on mutation. Useful to\n" \
"     * control integrity of the document.\n" \
"     */\n" \
"    public $cas;\n" \
"\n" \
"    /**\n" \
"     * @var array\n" \
"     *\n" \
"     * List of chained commands\n" \
"     */\n" \
"    private $commands = array();\n" \
"\n" \
"    private $bucket;\n" \
"\n" \
"    public function __construct($bucket, $id, $cas) {\n" \
"        $this->bucket = $bucket;\n" \
"        $this->id = $id;\n" \
"        $this->cas = $cas;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Inserts an element into a JSON document at a given path.\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param string $value An array value, scalar or any other valid JSON item.\n" \
"     * @param boolean $createParents If true, the parent will be added to the document.\n" \
"     */\n" \
"    public function insert($path, $value, $createParents = false) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_DICT_ADD,\n" \
"            'path' => $path,\n" \
"            'value' => $value,\n" \
"            'createParents' => $createParents,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Inserts or updates an element within or into a JSON document at a given path.\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param string $value An array value, scalar or any other valid JSON item.\n" \
"     * @param boolean $createParents If true, the parent will be added to the document.\n" \
"     */\n" \
"    public function upsert($path, $value, $createParents = false) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_DICT_UPSERT,\n" \
"            'path' => $path,\n" \
"            'value' => $value,\n" \
"            'createParents' => $createParents,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Replaces an element or value within a JSON document at a given path.\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param string $value An array value, scalar or any other valid JSON item.\n" \
"     */\n" \
"    public function replace($path, $value) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_REPLACE,\n" \
"            'path' => $path,\n" \
"            'value' => $value,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Removes an element or value from a JSON document at a given path.\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     */\n" \
"    public function remove($path) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_REMOVE,\n" \
"            'path' => $path,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Add a value to the beginning of an array at given path of a JSON document\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param mixed $value An array value, scalar or any other valid JSON item.\n" \
"     * @param boolean $createParents If true, the parent will be added to the document.\n" \
"     */\n" \
"    public function arrayPrepend($path, $value, $createParents = false) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_ARRAY_ADD_FIRST,\n" \
"            'path' => $path,\n" \
"            'value' => $value,\n" \
"            'createParents' => $createParents,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Add a value to the end of an array at given path of a JSON document\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param mixed $value An array value, scalar or any other valid JSON item.\n" \
"     * @param boolean $createParents If true, the parent will be added to the document.\n" \
"     */\n" \
"    public function arrayAppend($path, $value, $createParents = false) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_ARRAY_ADD_LAST,\n" \
"            'path' => $path,\n" \
"            'value' => $value,\n" \
"            'createParents' => $createParents,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Insert a value at given path of an array in a JSON document\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param mixed $value An array value, scalar or any other valid JSON item.\n" \
"     */\n" \
"    public function arrayInsert($path, $value) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_ARRAY_INSERT,\n" \
"            'path' => $path,\n" \
"            'value' => $value,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Add all values to the beginning of an array at given path of a JSON document\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param array $values An array of array values, scalars or any other valid JSON items.\n" \
"     * @param boolean $createParents If true, the parent will be added to the document.\n" \
"     */\n" \
"    public function arrayPrependAll($path, $values, $createParents = false) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_ARRAY_ADD_FIRST,\n" \
"            'path' => $path,\n" \
"            'value' => $values,\n" \
"            'createParents' => $createParents,\n" \
"            'removeBrackets' => true,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Add all values to the end of an array at given path of a JSON document\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param array $values An array of array values, scalars or any other valid JSON items.\n" \
"     * @param boolean $createParents If true, the parent will be added to the document.\n" \
"     */\n" \
"    public function arrayAppendAll($path, $values, $createParents = false) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_ARRAY_ADD_LAST,\n" \
"            'path' => $path,\n" \
"            'value' => $values,\n" \
"            'createParents' => $createParents,\n" \
"            'removeBrackets' => true,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Insert a value at given path of an array in a JSON document\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param array $values An array of array values, scalars or any other valid JSON items.\n" \
"     */\n" \
"    public function arrayInsertAll($path, $values) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_ARRAY_INSERT,\n" \
"            'path' => $path,\n" \
"            'value' => $values,\n" \
"            'removeBrackets' => true,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Add a value to an array at given path of a JSON document if it does not exist yet\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param string $value An array value, scalar or any other valid JSON item.\n" \
"     * @param boolean $createParents If true, the parent will be added to the document.\n" \
"     */\n" \
"    public function arrayAddUnique($path, $value, $createParents = false) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_ARRAY_ADD_UNIQUE,\n" \
"            'path' => $path,\n" \
"            'value' => $value,\n" \
"            'createParents' => $createParents,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Perform and arithmetic operation on a numeric value in a JSON document at given path\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     * @param string $delta The value to increment or decrement the original value by\n" \
"     * @param boolean $createParents If true, the parent will be added to the document.\n" \
"     */\n" \
"    public function counter($path, $delta, $createParents = false) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_COUNTER,\n" \
"            'path' => $path,\n" \
"            'value' => $delta,\n" \
"            'createParents' => $createParents,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function execute() {\n" \
"        if (empty($this->commands)) {\n" \
"            throw new CouchbaseException(\"There is should be at least command requested.\");\n" \
"        }\n" \
"        return $this->bucket->_subdoc($this->id, $this->commands, $this->cas);\n" \
"    }\n" \
"}\n" \
""},
{"[CouchbaseNative]/CouchbaseLookupInBuilder.class.php","\n" \
"/**\n" \
" * File for the CouchbaseLookupInBuilder class.\n" \
" *\n" \
" * @author Sergey Avseyev <sergey.avseyev@gmail.com>\n" \
" */\n" \
"\n" \
"/**\n" \
" * Represents a builder for subdocument lookup command.\n" \
" *\n" \
" * Note: This class must be constructed by calling the lookupIn()\n" \
" * method of the CouchbaseBucket class.\n" \
" *\n" \
" * @property integer $id\n" \
" *\n" \
" * @package Couchbase\n" \
" *\n" \
" * @see CouchbaseBucket::lookupIn()\n" \
" */\n" \
"class CouchbaseLookupInBuilder {\n" \
"    /**\n" \
"     * @var string\n" \
"     *\n" \
"     * Unique identifier for the document\n" \
"     */\n" \
"    public $id;\n" \
"\n" \
"    /**\n" \
"     * @var array\n" \
"     *\n" \
"     * List of chained commands\n" \
"     */\n" \
"    private $commands = array();\n" \
"\n" \
"    private $bucket;\n" \
"\n" \
"    public function __construct($bucket, $id) {\n" \
"        $this->bucket = $bucket;\n" \
"        $this->id = $id;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Gets the value at a specified N1QL path.\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     */\n" \
"    public function get($path) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_GET,\n" \
"            'path' => $path,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    /**\n" \
"     * Checks for the existence of a given N1QL path.\n" \
"     *\n" \
"     * @param string $path A string (N1QL syntax) used to specify a location within the document\n" \
"     */\n" \
"    public function exists($path) {\n" \
"        $this->commands[] = array(\n" \
"            'opcode' => COUCHBASE_SDCMD_EXISTS,\n" \
"            'path' => $path,\n" \
"        );\n" \
"        return $this;\n" \
"    }\n" \
"\n" \
"    public function execute() {\n" \
"        if (empty($this->commands)) {\n" \
"            throw new CouchbaseException(\"There is should be at least command requested.\");\n" \
"        }\n" \
"        return $this->bucket->_subdoc($this->id, $this->commands);\n" \
"    }\n" \
"}\n" \
""},
};
